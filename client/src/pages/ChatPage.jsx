import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { StreamChat } from 'stream-chat';
import { Chat, Channel, Window, ChannelHeader, MessageList, MessageInput, Thread } from 'stream-chat-react';
import 'stream-chat-react/dist/css/v2/index.css';
import { useStreamSession } from '../context/StreamSessionContext';
import axios from '../utils/axiosInstance';

const apiKey = 'p6yehc4e2xgg'; // Replace with actual key or env var

const ChatPage = () => {
    const { appointmentId } = useParams();
    const navigate = useNavigate();
    const { sessionData, setSession } = useStreamSession();
    const [chatClient, setChatClient] = useState(null);
    const [channel, setChannel] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const initChat = async () => {
            let currentSession = sessionData;
            console.log('Initial sessionData:', sessionData);

            if (!currentSession || currentSession.chatChannelId !== `chat_${appointmentId}`) {
                console.log('Fetching new token...');
                try {
                    const token = localStorage.getItem('token');
                    const { data } = await axios.post('http://localhost:5000/api/v1/stream/token',
                        { appointmentId, purpose: 'chat' },
                        {
                            headers: { Authorization: `Bearer ${token}` },
                            withCredentials: true
                        }
                    );
                    console.log('API Response:', data);
                    if (data.status === 'success') {
                        currentSession = data.data;
                        setSession(currentSession);
                    }
                } catch (error) {
                    console.error('Error fetching token:', error);
                    alert('Failed to join chat. Please try again.');
                    navigate('/dashboard');
                    return;
                }
            }

            console.log('Current Session before check:', currentSession);
            if (!currentSession) return;

            // Fallback if backend fails to return ID (should be generated by backend)
            if (!currentSession.chatChannelId) {
                console.warn('chatChannelId missing from backend, deriving from appointmentId');
                currentSession.chatChannelId = `chat_${appointmentId}`;
            }

            const client = StreamChat.getInstance(apiKey);

            try {
                // Prevent consecutive calls or reconnecting if already connected
                if (client.userID !== currentSession.userId) {
                    if (client.userID) {
                        await client.disconnectUser();
                    }
                    await client.connectUser(
                        {
                            id: currentSession.userId,
                            name: currentSession.userId, // Ideally fetch user name
                            image: `https://getstream.io/random_png/?id=${currentSession.userId}&name=${currentSession.userId}`,
                        },
                        currentSession.chatToken
                    );
                }
            } catch (error) {
                console.error('Error connecting user:', error);
            }

            const newChannel = client.channel('messaging', currentSession.chatChannelId, {
                name: `Appointment Chat`,
            });

            await newChannel.watch();

            setChatClient(client);
            setChannel(newChannel);
            setLoading(false);
        };

        initChat();

        return () => {
            // Cleanup logic if needed. 
            // Note: Disconnecting on unmount might be aggressive if the user navigates back quickly.
            // But for now, let's keep it simple.
            if (chatClient) {
                // chatClient.disconnectUser(); 
                // Commenting out disconnect to prevent "Consecutive calls" issues on rapid remounts
                // since we check userID on mount.
            }
        };
    }, [appointmentId, sessionData, setSession, navigate]);

    if (loading) return <div className="text-center mt-20">Loading chat...</div>;

    const isChatExpired = sessionData?.postConsultChatExpiresAt && new Date() > new Date(sessionData.postConsultChatExpiresAt);

    return (
        <div className="h-screen flex flex-col">
            <div className="bg-white shadow p-4 flex justify-between items-center">
                <h2 className="text-xl font-bold">Appointment Chat</h2>
                <button onClick={() => navigate('/dashboard')} className="text-blue-600 hover:underline">Back to Dashboard</button>
            </div>
            <div className="flex-1 overflow-hidden">
                <Chat client={chatClient} theme="messaging light">
                    <Channel channel={channel}>
                        <Window>
                            <ChannelHeader />
                            <MessageList />
                            {isChatExpired ? (
                                <div className="p-4 bg-gray-100 text-center text-gray-500">
                                    Post-consultation chat window has closed.
                                </div>
                            ) : (
                                <MessageInput />
                            )}
                        </Window>
                        <Thread />
                    </Channel>
                </Chat>
            </div>
        </div>
    );
};

export default ChatPage;
