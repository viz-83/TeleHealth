import { CommonApi } from './gen/common/CommonApi';
import { StreamVideoClient } from './StreamVideoClient';
import { StreamChatClient } from './StreamChatClient';
import { FileUploadRequest, ImageUploadRequest, QueryBannedUsersPayload, UserRequest } from './gen/models';
import { StreamModerationClient } from './StreamModerationClient';
import { StreamFeedsClient } from './StreamFeedsClient';
import { File } from 'buffer';
export interface StreamClientOptions {
    timeout?: number;
    basePath?: string;
    /** The [HTTP Agent](https://undici.nodejs.org/#/docs/api/Agent.md) to use. */
    agent?: unknown;
}
export declare class StreamClient extends CommonApi {
    readonly apiKey: string;
    private readonly secret;
    readonly config?: StreamClientOptions | undefined;
    readonly video: StreamVideoClient;
    readonly chat: StreamChatClient;
    readonly moderation: StreamModerationClient;
    readonly feeds: StreamFeedsClient;
    readonly options: StreamClientOptions;
    private static readonly DEFAULT_TIMEOUT;
    /**
     *
     * @param apiKey
     * @param secret
     * @param config config object
     */
    constructor(apiKey: string, secret: string, config?: StreamClientOptions | undefined);
    upsertUsers: (users: UserRequest[]) => Promise<import("./types").StreamResponse<import("./gen/models").UpdateUsersResponse>>;
    queryBannedUsers: (request?: {
        payload?: QueryBannedUsersPayload;
    }) => Promise<import("./types").StreamResponse<import("./gen/models").QueryBannedUsersResponse>>;
    uploadFile: (request: Omit<FileUploadRequest, "file"> & {
        file: File;
    }) => Promise<import("./types").StreamResponse<import("./gen/models").FileUploadResponse>>;
    uploadImage: (request: Omit<ImageUploadRequest, "file"> & {
        file: File;
    }) => Promise<import("./types").StreamResponse<import("./gen/models").ImageUploadResponse>>;
    /**
     *
     * @param payload
     * - user_id - the id of the user the token is for
     * - validity_in_seconds - how many seconds is the token valid for (starting from issued at), by default it's 1 hour, dicarded if exp is provided
     * - exp - when the token expires, unix timestamp in seconds
     * - iat - issued at date of the token, unix timestamp in seconds, by default it's now
     */
    generateUserToken: (payload: {
        user_id: string;
        validity_in_seconds?: number;
        exp?: number;
        iat?: number;
    } & Record<string, unknown>) => string;
    /**
     *
     * @param payload
     * - user_id - the id of the user the token is for
     * - iat - issued at date of the token, unix timestamp in seconds, by default it's now
     */
    generatePermanentUserToken: (payload: {
        user_id: string;
        iat?: number;
    } & Record<string, unknown>) => string;
    /**
     *
     * @param payload
     * - user_id - the id of the user the token is for
     * - validity_in_seconds - how many seconds is the token valid for (starting from issued at), by default it's 1 hour, dicarded if exp is provided
     * - exp - when the token expires, unix timestamp in seconds
     * - iat - issued at date of the token, unix timestamp in seconds, by default it's now
     */
    generateCallToken: (payload: {
        user_id: string;
        role?: string;
        call_cids: string[];
        validity_in_seconds?: number;
        exp?: number;
        iat?: number;
    } & Record<string, unknown>) => string;
    /**
     *
     * @param userID
     * @param exp
     * @param iat deprecated, the default date will be set internally
     * @returns
     *
     * @deprecated use generateUserToken instead
     */
    createToken: (userID: string, exp?: number, iat?: number) => string;
    /**
     *
     * @param userID
     * @param call_cids
     * @param exp
     * @param iat this is deprecated, the current date will be set internally
     * @returns
     *
     * @deprecated use generateCallToken instead
     */
    createCallToken: (userIdOrObject: string | {
        user_id: string;
        role?: string;
    }, call_cids: string[], exp?: number, iat?: number) => string;
    verifyWebhook: (requestBody: string | Buffer, xSignature: string) => boolean;
}
