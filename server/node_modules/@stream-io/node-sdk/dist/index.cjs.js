'use strict';

var jwt = require('jsonwebtoken');
var crypto = require('crypto');
var uuid = require('uuid');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

function JWTUserToken(apiSecret, payload) {
    // make sure we return a clear error when jwt is shimmed (ie. browser build)
    if (jwt == null || jwt.sign == null) {
        throw Error(`Unable to find jwt crypto, if you are getting this error is probably because you are trying to generate tokens on browser or React Native (or other environment where crypto functions are not available). Please Note: token should only be generated server-side.`);
    }
    const opts = Object.assign({
        algorithm: 'HS256',
        noTimestamp: true,
    });
    if (payload.iat) {
        opts.noTimestamp = false;
    }
    return jwt.sign(payload, apiSecret, opts);
}
function JWTServerToken(apiSecret, jwtOptions = {}) {
    const payload = {
        server: true,
    };
    const opts = Object.assign({ algorithm: 'HS256', noTimestamp: true }, jwtOptions);
    return jwt.sign(payload, apiSecret, opts);
}

const decoders = {};
const decodeDatetimeType = (input) => typeof input === 'number'
    ? new Date(Math.floor(input / 1000000))
    : new Date(input);
decoders.DatetimeType = decodeDatetimeType;
const decode = (typeMappings, input) => {
    if (!input || Object.keys(typeMappings).length === 0)
        return input;
    Object.keys(typeMappings).forEach((key) => {
        if (input[key] != null) {
            if (typeMappings[key]) {
                const decoder = decoders[typeMappings[key].type];
                if (decoder) {
                    if (typeMappings[key].isSingle) {
                        input[key] = decoder(input[key]);
                    }
                    else {
                        Object.keys(input[key]).forEach((k) => {
                            input[key][k] = decoder(input[key][k]);
                        });
                    }
                }
            }
        }
    });
    return input;
};
decoders.AcceptFeedMemberInviteResponse = (input) => {
    const typeMappings = {
        member: { type: 'FeedMemberResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AcceptFollowResponse = (input) => {
    const typeMappings = {
        follow: { type: 'FollowResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActionLogResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        review_queue_item: { type: 'ReviewQueueItemResponse', isSingle: true },
        target_user: { type: 'UserResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityAddedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityFeedbackEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityMarkEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityMarkedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityPinResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityPinnedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        pinned_activity: { type: 'PinActivityResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityReactionAddedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
        reaction: { type: 'FeedsReactionResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityReactionDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
        reaction: { type: 'FeedsReactionResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityReactionUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
        reaction: { type: 'FeedsReactionResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityRemovedFromFeedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        comments: { type: 'CommentResponse', isSingle: false },
        latest_reactions: { type: 'FeedsReactionResponse', isSingle: false },
        mentioned_users: { type: 'UserResponse', isSingle: false },
        own_bookmarks: { type: 'BookmarkResponse', isSingle: false },
        own_reactions: { type: 'FeedsReactionResponse', isSingle: false },
        collections: { type: 'EnrichedCollectionResponse', isSingle: false },
        reaction_groups: { type: 'ReactionGroupResponse', isSingle: false },
        user: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        edited_at: { type: 'DatetimeType', isSingle: true },
        expires_at: { type: 'DatetimeType', isSingle: true },
        current_feed: { type: 'FeedResponse', isSingle: true },
        parent: { type: 'ActivityResponse', isSingle: true },
        poll: { type: 'PollResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivitySelectorConfigResponse = (input) => {
    const typeMappings = {
        cutoff_time: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityUnpinnedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        pinned_activity: { type: 'PinActivityResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActivityUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AddActivityResponse = (input) => {
    const typeMappings = {
        activity: { type: 'ActivityResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AddBookmarkResponse = (input) => {
    const typeMappings = {
        bookmark: { type: 'BookmarkResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AddCommentReactionResponse = (input) => {
    const typeMappings = {
        comment: { type: 'CommentResponse', isSingle: true },
        reaction: { type: 'FeedsReactionResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AddCommentResponse = (input) => {
    const typeMappings = {
        comment: { type: 'CommentResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AddCommentsBatchResponse = (input) => {
    const typeMappings = {
        comments: { type: 'CommentResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.AddReactionResponse = (input) => {
    const typeMappings = {
        activity: { type: 'ActivityResponse', isSingle: true },
        reaction: { type: 'FeedsReactionResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AggregatedActivityResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        activities: { type: 'ActivityResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.AnyEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AppResponseFields = (input) => {
    const typeMappings = {
        event_hooks: { type: 'EventHook', isSingle: false },
        call_types: { type: 'CallType', isSingle: false },
        channel_configs: { type: 'ChannelConfig', isSingle: false },
        push_notifications: { type: 'PushNotificationFields', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AsyncBulkImageModerationEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        finished_at: { type: 'DatetimeType', isSingle: true },
        started_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AsyncExportChannelsEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        finished_at: { type: 'DatetimeType', isSingle: true },
        started_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AsyncExportErrorEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        finished_at: { type: 'DatetimeType', isSingle: true },
        started_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AsyncExportModerationLogsEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        finished_at: { type: 'DatetimeType', isSingle: true },
        started_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AsyncExportUsersEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        finished_at: { type: 'DatetimeType', isSingle: true },
        started_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AutomodDetails = (input) => {
    const typeMappings = {
        result: { type: 'MessageModerationResult', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Ban = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        expires: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'Channel', isSingle: true },
        created_by: { type: 'User', isSingle: true },
        target: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BanResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        expires: { type: 'DatetimeType', isSingle: true },
        banned_by: { type: 'UserResponse', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BlockListResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BlockUsersResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BlockedUserEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
        blocked_by_user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BlockedUserResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        blocked_user: { type: 'UserResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BookmarkAddedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        bookmark: { type: 'BookmarkResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BookmarkDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        bookmark: { type: 'BookmarkResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BookmarkFolderDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        bookmark_folder: { type: 'BookmarkFolderResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BookmarkFolderResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BookmarkFolderUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        bookmark_folder: { type: 'BookmarkFolderResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BookmarkResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
        folder: { type: 'BookmarkFolderResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BookmarkUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        bookmark: { type: 'BookmarkResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallAcceptedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallClosedCaptionsFailedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallClosedCaptionsStartedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallClosedCaptionsStoppedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallCreatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallEndedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallFrameRecordingFailedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallFrameRecordingFrameReadyEvent = (input) => {
    const typeMappings = {
        captured_at: { type: 'DatetimeType', isSingle: true },
        created_at: { type: 'DatetimeType', isSingle: true },
        users: { type: 'UserResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.CallFrameRecordingStartedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallFrameRecordingStoppedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallHLSBroadcastingFailedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallHLSBroadcastingStartedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallHLSBroadcastingStoppedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallLiveStartedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallMemberAddedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallMemberRemovedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallMemberUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallMemberUpdatedPermissionEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallMissedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallModerationBlurEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallModerationWarningEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallNotificationEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallParticipantResponse = (input) => {
    const typeMappings = {
        joined_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallParticipantTimeline = (input) => {
    const typeMappings = {
        timestamp: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallReactionEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        reaction: { type: 'ReactionResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallRecording = (input) => {
    const typeMappings = {
        end_time: { type: 'DatetimeType', isSingle: true },
        start_time: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallRecordingFailedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallRecordingReadyEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call_recording: { type: 'CallRecording', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallRecordingStartedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallRecordingStoppedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallRejectedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallReportResponse = (input) => {
    const typeMappings = {
        ended_at: { type: 'DatetimeType', isSingle: true },
        started_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        ended_at: { type: 'DatetimeType', isSingle: true },
        starts_at: { type: 'DatetimeType', isSingle: true },
        session: { type: 'CallSessionResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallRingEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallRtmpBroadcastFailedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallRtmpBroadcastStartedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallRtmpBroadcastStoppedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallSessionEndedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallSessionParticipantCountsUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallSessionParticipantJoinedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        participant: { type: 'CallParticipantResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallSessionParticipantLeftEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        participant: { type: 'CallParticipantResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallSessionResponse = (input) => {
    const typeMappings = {
        participants: { type: 'CallParticipantResponse', isSingle: false },
        accepted_by: { type: 'DatetimeType', isSingle: false },
        missed_by: { type: 'DatetimeType', isSingle: false },
        rejected_by: { type: 'DatetimeType', isSingle: false },
        ended_at: { type: 'DatetimeType', isSingle: true },
        live_ended_at: { type: 'DatetimeType', isSingle: true },
        live_started_at: { type: 'DatetimeType', isSingle: true },
        started_at: { type: 'DatetimeType', isSingle: true },
        timer_ends_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallSessionStartedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallStateResponseFields = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallStatsParticipant = (input) => {
    const typeMappings = {
        sessions: { type: 'CallStatsParticipantSession', isSingle: false },
        latest_activity_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallStatsParticipantSession = (input) => {
    const typeMappings = {
        ended_at: { type: 'DatetimeType', isSingle: true },
        started_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallStatsReportReadyEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallStatsReportSummaryResponse = (input) => {
    const typeMappings = {
        first_stats_time: { type: 'DatetimeType', isSingle: true },
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallTranscription = (input) => {
    const typeMappings = {
        end_time: { type: 'DatetimeType', isSingle: true },
        start_time: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallTranscriptionFailedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallTranscriptionReadyEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call_transcription: { type: 'CallTranscription', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallTranscriptionStartedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallTranscriptionStoppedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallType = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallUserFeedbackSubmittedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallUserMutedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CampaignCompletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        campaign: { type: 'CampaignResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CampaignResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        segments: { type: 'Segment', isSingle: false },
        users: { type: 'UserResponse', isSingle: false },
        stats: { type: 'CampaignStatsResponse', isSingle: true },
        scheduled_for: { type: 'DatetimeType', isSingle: true },
        stop_at: { type: 'DatetimeType', isSingle: true },
        sender: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CampaignStartedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        campaign: { type: 'CampaignResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CampaignStatsResponse = (input) => {
    const typeMappings = {
        stats_completed_at: { type: 'DatetimeType', isSingle: true },
        stats_started_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Channel = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_message_at: { type: 'DatetimeType', isSingle: true },
        message_count_updated_at: { type: 'DatetimeType', isSingle: true },
        active_live_locations: { type: 'SharedLocation', isSingle: false },
        invites: { type: 'ChannelMember', isSingle: false },
        members: { type: 'ChannelMember', isSingle: false },
        config: { type: 'ChannelConfig', isSingle: true },
        created_by: { type: 'User', isSingle: true },
        members_lookup: { type: 'ChannelMemberLookup', isSingle: false },
        truncated_by: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelConfig = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelConfigWithInfo = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        commands: { type: 'Command', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ChannelCreatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelFrozenEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelHiddenEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelMember = (input) => {
    const typeMappings = {
        archived_at: { type: 'DatetimeType', isSingle: true },
        ban_expires: { type: 'DatetimeType', isSingle: true },
        created_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        invite_accepted_at: { type: 'DatetimeType', isSingle: true },
        invite_rejected_at: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelMemberLookup = (input) => {
    const typeMappings = {
        archived_at: { type: 'DatetimeType', isSingle: true },
        ban_expires: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelMemberResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        archived_at: { type: 'DatetimeType', isSingle: true },
        ban_expires: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        invite_accepted_at: { type: 'DatetimeType', isSingle: true },
        invite_rejected_at: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelMute = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        expires: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelMutedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelPushPreferencesResponse = (input) => {
    const typeMappings = {
        disabled_until: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        hide_messages_before: { type: 'DatetimeType', isSingle: true },
        last_message_at: { type: 'DatetimeType', isSingle: true },
        mute_expires_at: { type: 'DatetimeType', isSingle: true },
        truncated_at: { type: 'DatetimeType', isSingle: true },
        members: { type: 'ChannelMemberResponse', isSingle: false },
        config: { type: 'ChannelConfigWithInfo', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        truncated_by: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelStateResponse = (input) => {
    const typeMappings = {
        members: { type: 'ChannelMemberResponse', isSingle: false },
        messages: { type: 'MessageResponse', isSingle: false },
        pinned_messages: { type: 'MessageResponse', isSingle: false },
        threads: { type: 'ThreadStateResponse', isSingle: false },
        hide_messages_before: { type: 'DatetimeType', isSingle: true },
        active_live_locations: {
            type: 'SharedLocationResponseData',
            isSingle: false,
        },
        pending_messages: { type: 'PendingMessageResponse', isSingle: false },
        read: { type: 'ReadStateResponse', isSingle: false },
        watchers: { type: 'UserResponse', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        draft: { type: 'DraftResponse', isSingle: true },
        membership: { type: 'ChannelMemberResponse', isSingle: true },
        push_preferences: {
            type: 'ChannelPushPreferencesResponse',
            isSingle: true,
        },
    };
    return decode(typeMappings, input);
};
decoders.ChannelStateResponseFields = (input) => {
    const typeMappings = {
        members: { type: 'ChannelMemberResponse', isSingle: false },
        messages: { type: 'MessageResponse', isSingle: false },
        pinned_messages: { type: 'MessageResponse', isSingle: false },
        threads: { type: 'ThreadStateResponse', isSingle: false },
        hide_messages_before: { type: 'DatetimeType', isSingle: true },
        active_live_locations: {
            type: 'SharedLocationResponseData',
            isSingle: false,
        },
        pending_messages: { type: 'PendingMessageResponse', isSingle: false },
        read: { type: 'ReadStateResponse', isSingle: false },
        watchers: { type: 'UserResponse', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        draft: { type: 'DraftResponse', isSingle: true },
        membership: { type: 'ChannelMemberResponse', isSingle: true },
        push_preferences: {
            type: 'ChannelPushPreferencesResponse',
            isSingle: true,
        },
    };
    return decode(typeMappings, input);
};
decoders.ChannelTruncatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelTypeConfig = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        commands: { type: 'Command', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ChannelUnFrozenEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelUnmutedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        message: { type: 'Message', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelVisibleEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChatActivityStatsResponse = (input) => {
    const typeMappings = {
        messages: { type: 'MessageStatsResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CheckResponse = (input) => {
    const typeMappings = {
        item: { type: 'ReviewQueueItemResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ClosedCaptionEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CollectionResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Command = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CommentAddedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
        comment: { type: 'CommentResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CommentDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        comment: { type: 'CommentResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CommentReactionAddedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
        comment: { type: 'CommentResponse', isSingle: true },
        reaction: { type: 'FeedsReactionResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CommentReactionDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        comment: { type: 'CommentResponse', isSingle: true },
        reaction: { type: 'FeedsReactionResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CommentReactionUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
        comment: { type: 'CommentResponse', isSingle: true },
        reaction: { type: 'FeedsReactionResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CommentResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        mentioned_users: { type: 'UserResponse', isSingle: false },
        own_reactions: { type: 'FeedsReactionResponse', isSingle: false },
        user: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        latest_reactions: { type: 'FeedsReactionResponse', isSingle: false },
        reaction_groups: { type: 'ReactionGroupResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.CommentUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        comment: { type: 'CommentResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ConfigResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CountByMinuteResponse = (input) => {
    const typeMappings = {
        start_ts: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateBlockListResponse = (input) => {
    const typeMappings = {
        blocklist: { type: 'BlockListResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateCallTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateChannelTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateCollectionsResponse = (input) => {
    const typeMappings = {
        collections: { type: 'CollectionResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.CreateCommandResponse = (input) => {
    const typeMappings = {
        command: { type: 'Command', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateFeedGroupResponse = (input) => {
    const typeMappings = {
        feed_group: { type: 'FeedGroupResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateFeedViewResponse = (input) => {
    const typeMappings = {
        feed_view: { type: 'FeedViewResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateFeedsBatchResponse = (input) => {
    const typeMappings = {
        feeds: { type: 'FeedResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.CreateGuestResponse = (input) => {
    const typeMappings = {
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateImportResponse = (input) => {
    const typeMappings = {
        import_task: { type: 'ImportTask', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateMembershipLevelResponse = (input) => {
    const typeMappings = {
        membership_level: { type: 'MembershipLevelResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateRoleResponse = (input) => {
    const typeMappings = {
        role: { type: 'Role', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateSIPTrunkResponse = (input) => {
    const typeMappings = {
        sip_trunk: { type: 'SIPTrunkResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CustomCheckResponse = (input) => {
    const typeMappings = {
        item: { type: 'ReviewQueueItemResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CustomVideoEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeactivateUserResponse = (input) => {
    const typeMappings = {
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeleteActivityReactionResponse = (input) => {
    const typeMappings = {
        activity: { type: 'ActivityResponse', isSingle: true },
        reaction: { type: 'FeedsReactionResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeleteBookmarkResponse = (input) => {
    const typeMappings = {
        bookmark: { type: 'BookmarkResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeleteCallResponse = (input) => {
    const typeMappings = {
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeleteChannelResponse = (input) => {
    const typeMappings = {
        channel: { type: 'ChannelResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeleteCommentReactionResponse = (input) => {
    const typeMappings = {
        comment: { type: 'CommentResponse', isSingle: true },
        reaction: { type: 'FeedsReactionResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeleteCommentResponse = (input) => {
    const typeMappings = {
        activity: { type: 'ActivityResponse', isSingle: true },
        comment: { type: 'CommentResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeleteMessageResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeleteReactionResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageResponse', isSingle: true },
        reaction: { type: 'ReactionResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Device = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeviceResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DraftPayloadResponse = (input) => {
    const typeMappings = {
        mentioned_users: { type: 'UserResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.DraftResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        message: { type: 'DraftPayloadResponse', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        parent_message: { type: 'MessageResponse', isSingle: true },
        quoted_message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.EgressRTMPResponse = (input) => {
    const typeMappings = {
        started_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.EnrichedCollectionResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.EntityCreatorResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        ban_expires: { type: 'DatetimeType', isSingle: true },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
        devices: { type: 'DeviceResponse', isSingle: false },
        push_notifications: {
            type: 'PushNotificationSettingsResponse',
            isSingle: true,
        },
    };
    return decode(typeMappings, input);
};
decoders.EventHook = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.EventResponse = (input) => {
    const typeMappings = {
        event: { type: 'WSEvent', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ExportUserResponse = (input) => {
    const typeMappings = {
        messages: { type: 'MessageResponse', isSingle: false },
        reactions: { type: 'ReactionResponse', isSingle: false },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FeedCreatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        members: { type: 'FeedMemberResponse', isSingle: false },
        feed: { type: 'FeedResponse', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FeedDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FeedGroupChangedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FeedGroupDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FeedGroupResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        activity_selectors: {
            type: 'ActivitySelectorConfigResponse',
            isSingle: false,
        },
    };
    return decode(typeMappings, input);
};
decoders.FeedMemberAddedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        member: { type: 'FeedMemberResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FeedMemberRemovedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FeedMemberResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
        invite_accepted_at: { type: 'DatetimeType', isSingle: true },
        invite_rejected_at: { type: 'DatetimeType', isSingle: true },
        membership_level: { type: 'MembershipLevelResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FeedMemberUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        member: { type: 'FeedMemberResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FeedResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        own_follows: { type: 'FollowResponse', isSingle: false },
        own_membership: { type: 'FeedMemberResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FeedSuggestionResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        own_follows: { type: 'FollowResponse', isSingle: false },
        own_membership: { type: 'FeedMemberResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FeedUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        feed: { type: 'FeedResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FeedViewResponse = (input) => {
    const typeMappings = {
        last_used_at: { type: 'DatetimeType', isSingle: true },
        activity_selectors: {
            type: 'ActivitySelectorConfigResponse',
            isSingle: false,
        },
    };
    return decode(typeMappings, input);
};
decoders.FeedsReactionResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FlagDetails = (input) => {
    const typeMappings = {
        automod: { type: 'AutomodDetails', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FlagFeedback = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FlagUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FollowBatchResponse = (input) => {
    const typeMappings = {
        follows: { type: 'FollowResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.FollowCreatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        follow: { type: 'FollowResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FollowDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        follow: { type: 'FollowResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FollowResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        source_feed: { type: 'FeedResponse', isSingle: true },
        target_feed: { type: 'FeedResponse', isSingle: true },
        request_accepted_at: { type: 'DatetimeType', isSingle: true },
        request_rejected_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FollowUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        follow: { type: 'FollowResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FullUserResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        channel_mutes: { type: 'ChannelMute', isSingle: false },
        devices: { type: 'DeviceResponse', isSingle: false },
        mutes: { type: 'UserMuteResponse', isSingle: false },
        ban_expires: { type: 'DatetimeType', isSingle: true },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetActiveCallsStatusResponse = (input) => {
    const typeMappings = {
        end_time: { type: 'DatetimeType', isSingle: true },
        start_time: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetActivityResponse = (input) => {
    const typeMappings = {
        activity: { type: 'ActivityResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetApplicationResponse = (input) => {
    const typeMappings = {
        app: { type: 'AppResponseFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetBlockListResponse = (input) => {
    const typeMappings = {
        blocklist: { type: 'BlockListResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetBlockedUsersResponse = (input) => {
    const typeMappings = {
        blocks: { type: 'BlockedUserResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetCallReportResponse = (input) => {
    const typeMappings = {
        video_reactions: { type: 'VideoReactionsResponse', isSingle: false },
        chat_activity: { type: 'ChatActivityStatsResponse', isSingle: true },
        session: { type: 'CallSessionResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetCallResponse = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetCallTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetChannelTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        commands: { type: 'Command', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetCommandResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetCommentRepliesResponse = (input) => {
    const typeMappings = {
        comments: { type: 'ThreadedCommentResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetCommentResponse = (input) => {
    const typeMappings = {
        comment: { type: 'CommentResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetCommentsResponse = (input) => {
    const typeMappings = {
        comments: { type: 'ThreadedCommentResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetConfigResponse = (input) => {
    const typeMappings = {
        config: { type: 'ConfigResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetDraftResponse = (input) => {
    const typeMappings = {
        draft: { type: 'DraftResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetFeedGroupResponse = (input) => {
    const typeMappings = {
        feed_group: { type: 'FeedGroupResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetFeedViewResponse = (input) => {
    const typeMappings = {
        feed_view: { type: 'FeedViewResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetFollowSuggestionsResponse = (input) => {
    const typeMappings = {
        suggestions: { type: 'FeedSuggestionResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetImportResponse = (input) => {
    const typeMappings = {
        import_task: { type: 'ImportTask', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetManyMessagesResponse = (input) => {
    const typeMappings = {
        messages: { type: 'MessageResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetMessageResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageWithChannelResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetModerationRuleResponse = (input) => {
    const typeMappings = {
        rule: { type: 'ModerationRuleV2Response', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetOrCreateCallResponse = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetOrCreateFeedGroupResponse = (input) => {
    const typeMappings = {
        feed_group: { type: 'FeedGroupResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetOrCreateFeedResponse = (input) => {
    const typeMappings = {
        activities: { type: 'ActivityResponse', isSingle: false },
        aggregated_activities: {
            type: 'AggregatedActivityResponse',
            isSingle: false,
        },
        followers: { type: 'FollowResponse', isSingle: false },
        following: { type: 'FollowResponse', isSingle: false },
        members: { type: 'FeedMemberResponse', isSingle: false },
        pinned_activities: { type: 'ActivityPinResponse', isSingle: false },
        feed: { type: 'FeedResponse', isSingle: true },
        notification_status: { type: 'NotificationStatusResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetOrCreateFeedViewResponse = (input) => {
    const typeMappings = {
        feed_view: { type: 'FeedViewResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetPushTemplatesResponse = (input) => {
    const typeMappings = {
        templates: { type: 'PushTemplate', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetReactionsResponse = (input) => {
    const typeMappings = {
        reactions: { type: 'ReactionResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetRepliesResponse = (input) => {
    const typeMappings = {
        messages: { type: 'MessageResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetReviewQueueItemResponse = (input) => {
    const typeMappings = {
        item: { type: 'ReviewQueueItemResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetSegmentResponse = (input) => {
    const typeMappings = {
        segment: { type: 'SegmentResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetTaskResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetThreadResponse = (input) => {
    const typeMappings = {
        thread: { type: 'ThreadStateResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GoLiveResponse = (input) => {
    const typeMappings = {
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ImportTask = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        history: { type: 'ImportTaskHistory', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ImportTaskHistory = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.KickedUserEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
        kicked_by_user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ListBlockListResponse = (input) => {
    const typeMappings = {
        blocklists: { type: 'BlockListResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListCallTypeResponse = (input) => {
    const typeMappings = {
        call_types: { type: 'CallTypeResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListChannelTypesResponse = (input) => {
    const typeMappings = {
        channel_types: { type: 'ChannelTypeConfig', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListCommandsResponse = (input) => {
    const typeMappings = {
        commands: { type: 'Command', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListDevicesResponse = (input) => {
    const typeMappings = {
        devices: { type: 'DeviceResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListFeedGroupsResponse = (input) => {
    const typeMappings = {
        groups: { type: 'FeedGroupResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListFeedViewsResponse = (input) => {
    const typeMappings = {
        views: { type: 'FeedViewResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListImportsResponse = (input) => {
    const typeMappings = {
        import_tasks: { type: 'ImportTask', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListPushProvidersResponse = (input) => {
    const typeMappings = {
        push_providers: { type: 'PushProviderResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListRecordingsResponse = (input) => {
    const typeMappings = {
        recordings: { type: 'CallRecording', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListRolesResponse = (input) => {
    const typeMappings = {
        roles: { type: 'Role', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListSIPInboundRoutingRuleResponse = (input) => {
    const typeMappings = {
        sip_inbound_routing_rules: {
            type: 'SIPInboundRoutingRuleResponse',
            isSingle: false,
        },
    };
    return decode(typeMappings, input);
};
decoders.ListSIPTrunksResponse = (input) => {
    const typeMappings = {
        sip_trunks: { type: 'SIPTrunkResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListTranscriptionsResponse = (input) => {
    const typeMappings = {
        transcriptions: { type: 'CallTranscription', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.MarkReadResponse = (input) => {
    const typeMappings = {
        event: { type: 'MessageReadEvent', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MemberAddedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        member: { type: 'ChannelMember', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MemberRemovedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        member: { type: 'ChannelMember', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MemberResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MemberUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        member: { type: 'ChannelMember', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MembersResponse = (input) => {
    const typeMappings = {
        members: { type: 'ChannelMemberResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.MembershipLevelResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Message = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_reactions: { type: 'Reaction', isSingle: false },
        mentioned_users: { type: 'User', isSingle: false },
        own_reactions: { type: 'Reaction', isSingle: false },
        reaction_groups: { type: 'ReactionGroupResponse', isSingle: false },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        message_text_updated_at: { type: 'DatetimeType', isSingle: true },
        pin_expires: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'User', isSingle: false },
        member: { type: 'ChannelMember', isSingle: true },
        pinned_by: { type: 'User', isSingle: true },
        poll: { type: 'Poll', isSingle: true },
        quoted_message: { type: 'Message', isSingle: true },
        reminder: { type: 'MessageReminder', isSingle: true },
        shared_location: { type: 'SharedLocation', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'User', isSingle: false },
        message: { type: 'Message', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageFlagResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        approved_at: { type: 'DatetimeType', isSingle: true },
        rejected_at: { type: 'DatetimeType', isSingle: true },
        reviewed_at: { type: 'DatetimeType', isSingle: true },
        details: { type: 'FlagDetails', isSingle: true },
        message: { type: 'Message', isSingle: true },
        moderation_feedback: { type: 'FlagFeedback', isSingle: true },
        moderation_result: { type: 'MessageModerationResult', isSingle: true },
        reviewed_by: { type: 'UserResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageFlaggedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'User', isSingle: false },
        message: { type: 'Message', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageHistoryEntryResponse = (input) => {
    const typeMappings = {
        message_updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageModerationResult = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageNewEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'User', isSingle: false },
        message: { type: 'Message', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageReadEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        channel_last_message_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        thread: { type: 'ThreadResponse', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageReminder = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        remind_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'Channel', isSingle: true },
        message: { type: 'Message', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_reactions: { type: 'ReactionResponse', isSingle: false },
        mentioned_users: { type: 'UserResponse', isSingle: false },
        own_reactions: { type: 'ReactionResponse', isSingle: false },
        user: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        message_text_updated_at: { type: 'DatetimeType', isSingle: true },
        pin_expires: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'UserResponse', isSingle: false },
        draft: { type: 'DraftResponse', isSingle: true },
        member: { type: 'ChannelMemberResponse', isSingle: true },
        pinned_by: { type: 'UserResponse', isSingle: true },
        poll: { type: 'PollResponseData', isSingle: true },
        quoted_message: { type: 'MessageResponse', isSingle: true },
        reaction_groups: { type: 'ReactionGroupResponse', isSingle: false },
        reminder: { type: 'ReminderResponseData', isSingle: true },
        shared_location: { type: 'SharedLocationResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageStatsResponse = (input) => {
    const typeMappings = {
        count_over_time: { type: 'CountByMinuteResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.MessageUnblockedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'User', isSingle: false },
        message: { type: 'Message', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageUndeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'User', isSingle: false },
        message: { type: 'Message', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'User', isSingle: false },
        message: { type: 'Message', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageWithChannelResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_reactions: { type: 'ReactionResponse', isSingle: false },
        mentioned_users: { type: 'UserResponse', isSingle: false },
        own_reactions: { type: 'ReactionResponse', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        message_text_updated_at: { type: 'DatetimeType', isSingle: true },
        pin_expires: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'UserResponse', isSingle: false },
        draft: { type: 'DraftResponse', isSingle: true },
        member: { type: 'ChannelMemberResponse', isSingle: true },
        pinned_by: { type: 'UserResponse', isSingle: true },
        poll: { type: 'PollResponseData', isSingle: true },
        quoted_message: { type: 'MessageResponse', isSingle: true },
        reaction_groups: { type: 'ReactionGroupResponse', isSingle: false },
        reminder: { type: 'ReminderResponseData', isSingle: true },
        shared_location: { type: 'SharedLocationResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ModerationCheckCompletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ModerationCustomActionEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        review_queue_item: { type: 'ReviewQueueItemResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ModerationFlagResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        review_queue_item: { type: 'ReviewQueueItemResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ModerationFlaggedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ModerationMarkReviewedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        item: { type: 'ReviewQueueItemResponse', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ModerationRuleV2Response = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MuteChannelResponse = (input) => {
    const typeMappings = {
        channel_mutes: { type: 'ChannelMute', isSingle: false },
        channel_mute: { type: 'ChannelMute', isSingle: true },
        own_user: { type: 'OwnUser', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MuteResponse = (input) => {
    const typeMappings = {
        mutes: { type: 'UserMute', isSingle: false },
        own_user: { type: 'OwnUser', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.NotificationFeedUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        aggregated_activities: {
            type: 'AggregatedActivityResponse',
            isSingle: false,
        },
        notification_status: { type: 'NotificationStatusResponse', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.NotificationMarkUnreadEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        last_read_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.NotificationStatusResponse = (input) => {
    const typeMappings = {
        last_read_at: { type: 'DatetimeType', isSingle: true },
        last_seen_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.OwnUser = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        channel_mutes: { type: 'ChannelMute', isSingle: false },
        devices: { type: 'Device', isSingle: false },
        mutes: { type: 'UserMute', isSingle: false },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        last_engaged_at: { type: 'DatetimeType', isSingle: true },
        push_preferences: { type: 'PushPreferences', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.OwnUserResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        channel_mutes: { type: 'ChannelMute', isSingle: false },
        devices: { type: 'DeviceResponse', isSingle: false },
        mutes: { type: 'UserMuteResponse', isSingle: false },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
        push_preferences: { type: 'PushPreferencesResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ParticipantCountByMinuteResponse = (input) => {
    const typeMappings = {
        start_ts: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ParticipantCountOverTimeResponse = (input) => {
    const typeMappings = {
        by_minute: { type: 'ParticipantCountByMinuteResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ParticipantSeriesTimeframe = (input) => {
    const typeMappings = {
        since: { type: 'DatetimeType', isSingle: true },
        until: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PendingMessageEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'Channel', isSingle: true },
        message: { type: 'Message', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PendingMessageResponse = (input) => {
    const typeMappings = {
        channel: { type: 'ChannelResponse', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PermissionRequestEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PinActivityResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        activity: { type: 'ActivityResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Poll = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_answers: { type: 'PollVote', isSingle: false },
        own_votes: { type: 'PollVote', isSingle: false },
        created_by: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PollResponse = (input) => {
    const typeMappings = {
        poll: { type: 'PollResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PollResponseData = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_answers: { type: 'PollVoteResponseData', isSingle: false },
        own_votes: { type: 'PollVoteResponseData', isSingle: false },
        created_by: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PollVote = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PollVoteResponse = (input) => {
    const typeMappings = {
        vote: { type: 'PollVoteResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PollVoteResponseData = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PollVotesResponse = (input) => {
    const typeMappings = {
        votes: { type: 'PollVoteResponseData', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.PushNotificationFields = (input) => {
    const typeMappings = {
        providers: { type: 'PushProvider', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.PushNotificationSettingsResponse = (input) => {
    const typeMappings = {
        disabled_until: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PushPreferences = (input) => {
    const typeMappings = {
        disabled_until: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PushPreferencesResponse = (input) => {
    const typeMappings = {
        disabled_until: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PushProvider = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        disabled_at: { type: 'DatetimeType', isSingle: true },
        push_templates: { type: 'PushTemplate', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.PushProviderResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        disabled_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PushTemplate = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.QueryActivitiesResponse = (input) => {
    const typeMappings = {
        activities: { type: 'ActivityResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryActivityReactionsResponse = (input) => {
    const typeMappings = {
        reactions: { type: 'FeedsReactionResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryBannedUsersResponse = (input) => {
    const typeMappings = {
        bans: { type: 'BanResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryBookmarkFoldersResponse = (input) => {
    const typeMappings = {
        bookmark_folders: { type: 'BookmarkFolderResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryBookmarksResponse = (input) => {
    const typeMappings = {
        bookmarks: { type: 'BookmarkResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryCallMembersResponse = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryCallParticipantsResponse = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
        participants: { type: 'CallParticipantResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.QueryCallSessionParticipantStatsResponse = (input) => {
    const typeMappings = {
        participants: { type: 'CallStatsParticipant', isSingle: false },
        call_ended_at: { type: 'DatetimeType', isSingle: true },
        call_started_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.QueryCallSessionParticipantStatsTimelineResponse = (input) => {
    const typeMappings = {
        events: { type: 'CallParticipantTimeline', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryCallStatsResponse = (input) => {
    const typeMappings = {
        reports: { type: 'CallStatsReportSummaryResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryCallsResponse = (input) => {
    const typeMappings = {
        calls: { type: 'CallStateResponseFields', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryCampaignsResponse = (input) => {
    const typeMappings = {
        campaigns: { type: 'CampaignResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryChannelsResponse = (input) => {
    const typeMappings = {
        channels: { type: 'ChannelStateResponseFields', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryCommentReactionsResponse = (input) => {
    const typeMappings = {
        reactions: { type: 'FeedsReactionResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryCommentsResponse = (input) => {
    const typeMappings = {
        comments: { type: 'CommentResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryDraftsResponse = (input) => {
    const typeMappings = {
        drafts: { type: 'DraftResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryFeedMembersResponse = (input) => {
    const typeMappings = {
        members: { type: 'FeedMemberResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryFeedModerationTemplate = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.QueryFeedModerationTemplatesResponse = (input) => {
    const typeMappings = {
        templates: { type: 'QueryFeedModerationTemplate', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryFeedsResponse = (input) => {
    const typeMappings = {
        feeds: { type: 'FeedResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryFollowsResponse = (input) => {
    const typeMappings = {
        follows: { type: 'FollowResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryMembershipLevelsResponse = (input) => {
    const typeMappings = {
        membership_levels: { type: 'MembershipLevelResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryMessageFlagsResponse = (input) => {
    const typeMappings = {
        flags: { type: 'MessageFlagResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryMessageHistoryResponse = (input) => {
    const typeMappings = {
        message_history: { type: 'MessageHistoryEntryResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryModerationConfigsResponse = (input) => {
    const typeMappings = {
        configs: { type: 'ConfigResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryModerationFlagsResponse = (input) => {
    const typeMappings = {
        flags: { type: 'ModerationFlagResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryModerationLogsResponse = (input) => {
    const typeMappings = {
        logs: { type: 'ActionLogResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryModerationRulesResponse = (input) => {
    const typeMappings = {
        rules: { type: 'ModerationRuleV2Response', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryPollsResponse = (input) => {
    const typeMappings = {
        polls: { type: 'PollResponseData', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryReactionsResponse = (input) => {
    const typeMappings = {
        reactions: { type: 'ReactionResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryRemindersResponse = (input) => {
    const typeMappings = {
        reminders: { type: 'ReminderResponseData', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QuerySegmentTargetsResponse = (input) => {
    const typeMappings = {
        targets: { type: 'SegmentTargetResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QuerySegmentsResponse = (input) => {
    const typeMappings = {
        segments: { type: 'SegmentResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryThreadsResponse = (input) => {
    const typeMappings = {
        threads: { type: 'ThreadStateResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryUsersResponse = (input) => {
    const typeMappings = {
        users: { type: 'FullUserResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.Reaction = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReactionDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'User', isSingle: false },
        message: { type: 'Message', isSingle: true },
        reaction: { type: 'Reaction', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReactionGroupResponse = (input) => {
    const typeMappings = {
        first_reaction_at: { type: 'DatetimeType', isSingle: true },
        last_reaction_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReactionNewEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'User', isSingle: false },
        message: { type: 'Message', isSingle: true },
        reaction: { type: 'Reaction', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReactionResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReactionUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        message: { type: 'Message', isSingle: true },
        reaction: { type: 'Reaction', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReactivateUserResponse = (input) => {
    const typeMappings = {
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReadCollectionsResponse = (input) => {
    const typeMappings = {
        collections: { type: 'CollectionResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ReadStateResponse = (input) => {
    const typeMappings = {
        last_read: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
        last_delivered_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.RejectFeedMemberInviteResponse = (input) => {
    const typeMappings = {
        member: { type: 'FeedMemberResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.RejectFollowResponse = (input) => {
    const typeMappings = {
        follow: { type: 'FollowResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReminderCreatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        reminder: { type: 'ReminderResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReminderDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        reminder: { type: 'ReminderResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReminderNotificationEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        reminder: { type: 'ReminderResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReminderResponseData = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        remind_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReminderUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        reminder: { type: 'ReminderResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ResolveSipInboundResponse = (input) => {
    const typeMappings = {
        sip_routing_rule: { type: 'SIPInboundRoutingRuleResponse', isSingle: true },
        sip_trunk: { type: 'SIPTrunkResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReviewQueueItemNewEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        flags: { type: 'ModerationFlagResponse', isSingle: false },
        action: { type: 'ActionLogResponse', isSingle: true },
        review_queue_item: { type: 'ReviewQueueItemResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReviewQueueItemResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        actions: { type: 'ActionLogResponse', isSingle: false },
        bans: { type: 'Ban', isSingle: false },
        flags: { type: 'ModerationFlagResponse', isSingle: false },
        completed_at: { type: 'DatetimeType', isSingle: true },
        reviewed_at: { type: 'DatetimeType', isSingle: true },
        assigned_to: { type: 'UserResponse', isSingle: true },
        call: { type: 'CallResponse', isSingle: true },
        entity_creator: { type: 'EntityCreatorResponse', isSingle: true },
        feeds_v2_reaction: { type: 'Reaction', isSingle: true },
        feeds_v3_activity: { type: 'ActivityResponse', isSingle: true },
        feeds_v3_comment: { type: 'CommentResponse', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
        reaction: { type: 'Reaction', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReviewQueueItemUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        flags: { type: 'ModerationFlagResponse', isSingle: false },
        action: { type: 'ActionLogResponse', isSingle: true },
        review_queue_item: { type: 'ReviewQueueItemResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Role = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SIPInboundRoutingRuleResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SIPTrunkResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SearchResult = (input) => {
    const typeMappings = {
        message: { type: 'SearchResultMessage', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SearchResultMessage = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_reactions: { type: 'ReactionResponse', isSingle: false },
        mentioned_users: { type: 'UserResponse', isSingle: false },
        own_reactions: { type: 'ReactionResponse', isSingle: false },
        user: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        message_text_updated_at: { type: 'DatetimeType', isSingle: true },
        pin_expires: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'UserResponse', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        draft: { type: 'DraftResponse', isSingle: true },
        member: { type: 'ChannelMemberResponse', isSingle: true },
        pinned_by: { type: 'UserResponse', isSingle: true },
        poll: { type: 'PollResponseData', isSingle: true },
        quoted_message: { type: 'MessageResponse', isSingle: true },
        reaction_groups: { type: 'ReactionGroupResponse', isSingle: false },
        reminder: { type: 'ReminderResponseData', isSingle: true },
        shared_location: { type: 'SharedLocationResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Segment = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SegmentResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SegmentTargetResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SendMessageResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SendReactionResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageResponse', isSingle: true },
        reaction: { type: 'ReactionResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SharedLocation = (input) => {
    const typeMappings = {
        end_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SharedLocationResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        end_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SharedLocationResponseData = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        end_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SharedLocationsResponse = (input) => {
    const typeMappings = {
        active_live_locations: {
            type: 'SharedLocationResponseData',
            isSingle: false,
        },
    };
    return decode(typeMappings, input);
};
decoders.SingleFollowResponse = (input) => {
    const typeMappings = {
        follow: { type: 'FollowResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.StopLiveResponse = (input) => {
    const typeMappings = {
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.StoriesFeedUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
        activities: { type: 'ActivityResponse', isSingle: false },
        aggregated_activities: {
            type: 'AggregatedActivityResponse',
            isSingle: false,
        },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SubmitActionResponse = (input) => {
    const typeMappings = {
        item: { type: 'ReviewQueueItemResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ThreadParticipant = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        last_read_at: { type: 'DatetimeType', isSingle: true },
        last_thread_message_at: { type: 'DatetimeType', isSingle: true },
        left_thread_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ThreadResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_message_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'ThreadParticipant', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        parent_message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ThreadStateResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_replies: { type: 'MessageResponse', isSingle: false },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_message_at: { type: 'DatetimeType', isSingle: true },
        read: { type: 'ReadStateResponse', isSingle: false },
        thread_participants: { type: 'ThreadParticipant', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        draft: { type: 'DraftResponse', isSingle: true },
        parent_message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ThreadUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        thread: { type: 'ThreadResponse', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ThreadedCommentResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        mentioned_users: { type: 'UserResponse', isSingle: false },
        own_reactions: { type: 'FeedsReactionResponse', isSingle: false },
        user: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        latest_reactions: { type: 'FeedsReactionResponse', isSingle: false },
        replies: { type: 'ThreadedCommentResponse', isSingle: false },
        reaction_groups: { type: 'ReactionGroupResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.TruncateChannelResponse = (input) => {
    const typeMappings = {
        channel: { type: 'ChannelResponse', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UnblockedUserEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UnfollowBatchResponse = (input) => {
    const typeMappings = {
        follows: { type: 'FollowResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UnfollowResponse = (input) => {
    const typeMappings = {
        follow: { type: 'FollowResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UnpinActivityResponse = (input) => {
    const typeMappings = {
        activity: { type: 'ActivityResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UnreadCountsBatchResponse = (input) => {
    const typeMappings = {
        counts_by_user: { type: 'UnreadCountsResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UnreadCountsChannel = (input) => {
    const typeMappings = {
        last_read: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UnreadCountsResponse = (input) => {
    const typeMappings = {
        channels: { type: 'UnreadCountsChannel', isSingle: false },
        threads: { type: 'UnreadCountsThread', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UnreadCountsThread = (input) => {
    const typeMappings = {
        last_read: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateActivityPartialResponse = (input) => {
    const typeMappings = {
        activity: { type: 'ActivityResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateActivityResponse = (input) => {
    const typeMappings = {
        activity: { type: 'ActivityResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateBlockListResponse = (input) => {
    const typeMappings = {
        blocklist: { type: 'BlockListResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateBookmarkFolderResponse = (input) => {
    const typeMappings = {
        bookmark_folder: { type: 'BookmarkFolderResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateBookmarkResponse = (input) => {
    const typeMappings = {
        bookmark: { type: 'BookmarkResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateCallMembersResponse = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UpdateCallResponse = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateCallTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateChannelPartialResponse = (input) => {
    const typeMappings = {
        members: { type: 'ChannelMemberResponse', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateChannelResponse = (input) => {
    const typeMappings = {
        members: { type: 'ChannelMemberResponse', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateChannelTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateCollectionsResponse = (input) => {
    const typeMappings = {
        collections: { type: 'CollectionResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UpdateCommandResponse = (input) => {
    const typeMappings = {
        command: { type: 'Command', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateCommentResponse = (input) => {
    const typeMappings = {
        comment: { type: 'CommentResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateFeedGroupResponse = (input) => {
    const typeMappings = {
        feed_group: { type: 'FeedGroupResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateFeedMembersResponse = (input) => {
    const typeMappings = {
        added: { type: 'FeedMemberResponse', isSingle: false },
        updated: { type: 'FeedMemberResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UpdateFeedResponse = (input) => {
    const typeMappings = {
        feed: { type: 'FeedResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateFeedViewResponse = (input) => {
    const typeMappings = {
        feed_view: { type: 'FeedViewResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateFollowResponse = (input) => {
    const typeMappings = {
        follow: { type: 'FollowResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateMemberPartialResponse = (input) => {
    const typeMappings = {
        channel_member: { type: 'ChannelMemberResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateMembershipLevelResponse = (input) => {
    const typeMappings = {
        membership_level: { type: 'MembershipLevelResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateMessagePartialResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateMessageResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateReminderResponse = (input) => {
    const typeMappings = {
        reminder: { type: 'ReminderResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateSIPInboundRoutingRuleResponse = (input) => {
    const typeMappings = {
        sip_inbound_routing_rule: {
            type: 'SIPInboundRoutingRuleResponse',
            isSingle: true,
        },
    };
    return decode(typeMappings, input);
};
decoders.UpdateSIPTrunkResponse = (input) => {
    const typeMappings = {
        sip_trunk: { type: 'SIPTrunkResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateThreadPartialResponse = (input) => {
    const typeMappings = {
        thread: { type: 'ThreadResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateUsersResponse = (input) => {
    const typeMappings = {
        users: { type: 'FullUserResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UpdatedCallPermissionsEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpsertActivitiesResponse = (input) => {
    const typeMappings = {
        activities: { type: 'ActivityResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UpsertCollectionsResponse = (input) => {
    const typeMappings = {
        collections: { type: 'CollectionResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UpsertConfigResponse = (input) => {
    const typeMappings = {
        config: { type: 'ConfigResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpsertModerationRuleResponse = (input) => {
    const typeMappings = {
        rule: { type: 'ModerationRuleV2Response', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpsertModerationTemplateResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpsertPushPreferencesResponse = (input) => {
    const typeMappings = {
        user_preferences: { type: 'PushPreferences', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UpsertPushProviderResponse = (input) => {
    const typeMappings = {
        push_provider: { type: 'PushProviderResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpsertPushTemplateResponse = (input) => {
    const typeMappings = {
        template: { type: 'PushTemplate', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.User = (input) => {
    const typeMappings = {
        ban_expires: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserBannedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        created_by: { type: 'User', isSingle: true },
        expiration: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserDeactivatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        created_by: { type: 'User', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserFlaggedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserMessagesDeletedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserMute = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        expires: { type: 'DatetimeType', isSingle: true },
        target: { type: 'User', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserMuteResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        expires: { type: 'DatetimeType', isSingle: true },
        target: { type: 'UserResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserMutedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserReactivatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        ban_expires: { type: 'DatetimeType', isSingle: true },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
        devices: { type: 'DeviceResponse', isSingle: false },
        push_notifications: {
            type: 'PushNotificationSettingsResponse',
            isSingle: true,
        },
    };
    return decode(typeMappings, input);
};
decoders.UserResponseCommonFields = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserUnbannedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserUnmutedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserUnreadReminderEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserUpdatedEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        received_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.VideoReactionOverTimeResponse = (input) => {
    const typeMappings = {
        by_minute: { type: 'CountByMinuteResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.VideoReactionsResponse = (input) => {
    const typeMappings = {
        count_over_time: { type: 'VideoReactionOverTimeResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.WSEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        channel_last_message_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        me: { type: 'OwnUserResponse', isSingle: true },
        member: { type: 'ChannelMemberResponse', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
        poll: { type: 'PollResponseData', isSingle: true },
        poll_vote: { type: 'PollVoteResponseData', isSingle: true },
        reaction: { type: 'ReactionResponse', isSingle: true },
        thread: { type: 'ThreadResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.WrappedUnreadCountsResponse = (input) => {
    const typeMappings = {
        channels: { type: 'UnreadCountsChannel', isSingle: false },
        threads: { type: 'UnreadCountsThread', isSingle: false },
    };
    return decode(typeMappings, input);
};

class CommonApi {
    constructor(apiClient) {
        this.apiClient = apiClient;
    }
    async getApp() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/app', undefined, undefined);
        decoders.GetApplicationResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateApp(request) {
        const body = {
            async_url_enrich_enabled: request?.async_url_enrich_enabled,
            auto_translation_enabled: request?.auto_translation_enabled,
            before_message_send_hook_url: request?.before_message_send_hook_url,
            cdn_expiration_seconds: request?.cdn_expiration_seconds,
            channel_hide_members_only: request?.channel_hide_members_only,
            custom_action_handler_url: request?.custom_action_handler_url,
            disable_auth_checks: request?.disable_auth_checks,
            disable_permissions_checks: request?.disable_permissions_checks,
            enforce_unique_usernames: request?.enforce_unique_usernames,
            feeds_moderation_enabled: request?.feeds_moderation_enabled,
            feeds_v2_region: request?.feeds_v2_region,
            guest_user_creation_disabled: request?.guest_user_creation_disabled,
            image_moderation_enabled: request?.image_moderation_enabled,
            max_aggregated_activities_length: request?.max_aggregated_activities_length,
            migrate_permissions_to_v2: request?.migrate_permissions_to_v2,
            moderation_enabled: request?.moderation_enabled,
            moderation_webhook_url: request?.moderation_webhook_url,
            multi_tenant_enabled: request?.multi_tenant_enabled,
            permission_version: request?.permission_version,
            reminders_interval: request?.reminders_interval,
            reminders_max_members: request?.reminders_max_members,
            revoke_tokens_issued_before: request?.revoke_tokens_issued_before,
            sns_key: request?.sns_key,
            sns_secret: request?.sns_secret,
            sns_topic_arn: request?.sns_topic_arn,
            sqs_key: request?.sqs_key,
            sqs_secret: request?.sqs_secret,
            sqs_url: request?.sqs_url,
            user_response_time_enabled: request?.user_response_time_enabled,
            webhook_url: request?.webhook_url,
            allowed_flag_reasons: request?.allowed_flag_reasons,
            event_hooks: request?.event_hooks,
            image_moderation_block_labels: request?.image_moderation_block_labels,
            image_moderation_labels: request?.image_moderation_labels,
            user_search_disallowed_roles: request?.user_search_disallowed_roles,
            webhook_events: request?.webhook_events,
            apn_config: request?.apn_config,
            async_moderation_config: request?.async_moderation_config,
            datadog_info: request?.datadog_info,
            file_upload_config: request?.file_upload_config,
            firebase_config: request?.firebase_config,
            grants: request?.grants,
            huawei_config: request?.huawei_config,
            image_upload_config: request?.image_upload_config,
            moderation_dashboard_preferences: request?.moderation_dashboard_preferences,
            push_config: request?.push_config,
            xiaomi_config: request?.xiaomi_config,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/app', undefined, undefined, body, 'application/json');
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listBlockLists(request) {
        const queryParams = {
            team: request?.team,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/blocklists', undefined, queryParams);
        decoders.ListBlockListResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createBlockList(request) {
        const body = {
            name: request?.name,
            words: request?.words,
            is_leet_check_enabled: request?.is_leet_check_enabled,
            is_plural_check_enabled: request?.is_plural_check_enabled,
            team: request?.team,
            type: request?.type,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/blocklists', undefined, undefined, body, 'application/json');
        decoders.CreateBlockListResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteBlockList(request) {
        const queryParams = {
            team: request?.team,
        };
        const pathParams = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/blocklists/{name}', pathParams, queryParams);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getBlockList(request) {
        const queryParams = {
            team: request?.team,
        };
        const pathParams = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/blocklists/{name}', pathParams, queryParams);
        decoders.GetBlockListResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateBlockList(request) {
        const pathParams = {
            name: request?.name,
        };
        const body = {
            is_leet_check_enabled: request?.is_leet_check_enabled,
            is_plural_check_enabled: request?.is_plural_check_enabled,
            team: request?.team,
            words: request?.words,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/blocklists/{name}', pathParams, undefined, body, 'application/json');
        decoders.UpdateBlockListResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async checkPush(request) {
        const body = {
            apn_template: request?.apn_template,
            event_type: request?.event_type,
            firebase_data_template: request?.firebase_data_template,
            firebase_template: request?.firebase_template,
            message_id: request?.message_id,
            push_provider_name: request?.push_provider_name,
            push_provider_type: request?.push_provider_type,
            skip_devices: request?.skip_devices,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/check_push', undefined, undefined, body, 'application/json');
        decoders.CheckPushResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async checkSNS(request) {
        const body = {
            sns_key: request?.sns_key,
            sns_secret: request?.sns_secret,
            sns_topic_arn: request?.sns_topic_arn,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/check_sns', undefined, undefined, body, 'application/json');
        decoders.CheckSNSResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async checkSQS(request) {
        const body = {
            sqs_key: request?.sqs_key,
            sqs_secret: request?.sqs_secret,
            sqs_url: request?.sqs_url,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/check_sqs', undefined, undefined, body, 'application/json');
        decoders.CheckSQSResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteDevice(request) {
        const queryParams = {
            id: request?.id,
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/devices', undefined, queryParams);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listDevices(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/devices', undefined, queryParams);
        decoders.ListDevicesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createDevice(request) {
        const body = {
            id: request?.id,
            push_provider: request?.push_provider,
            push_provider_name: request?.push_provider_name,
            user_id: request?.user_id,
            voip_token: request?.voip_token,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/devices', undefined, undefined, body, 'application/json');
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async exportUsers(request) {
        const body = {
            user_ids: request?.user_ids,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/export/users', undefined, undefined, body, 'application/json');
        decoders.ExportUsersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listExternalStorage() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/external_storage', undefined, undefined);
        decoders.ListExternalStorageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createExternalStorage(request) {
        const body = {
            bucket: request?.bucket,
            name: request?.name,
            storage_type: request?.storage_type,
            gcs_credentials: request?.gcs_credentials,
            path: request?.path,
            aws_s3: request?.aws_s3,
            azure_blob: request?.azure_blob,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/external_storage', undefined, undefined, body, 'application/json');
        decoders.CreateExternalStorageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteExternalStorage(request) {
        const pathParams = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/external_storage/{name}', pathParams, undefined);
        decoders.DeleteExternalStorageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateExternalStorage(request) {
        const pathParams = {
            name: request?.name,
        };
        const body = {
            bucket: request?.bucket,
            storage_type: request?.storage_type,
            gcs_credentials: request?.gcs_credentials,
            path: request?.path,
            aws_s3: request?.aws_s3,
            azure_blob: request?.azure_blob,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/external_storage/{name}', pathParams, undefined, body, 'application/json');
        decoders.UpdateExternalStorageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async checkExternalStorage(request) {
        const pathParams = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/external_storage/{name}/check', pathParams, undefined);
        decoders.CheckExternalStorageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createGuest(request) {
        const body = {
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/guest', undefined, undefined, body, 'application/json');
        decoders.CreateGuestResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createImportURL(request) {
        const body = {
            filename: request?.filename,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/import_urls', undefined, undefined, body, 'application/json');
        decoders.CreateImportURLResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listImports() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/imports', undefined, undefined);
        decoders.ListImportsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createImport(request) {
        const body = {
            mode: request?.mode,
            path: request?.path,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/imports', undefined, undefined, body, 'application/json');
        decoders.CreateImportResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getImport(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/imports/{id}', pathParams, undefined);
        decoders.GetImportResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getOG(request) {
        const queryParams = {
            url: request?.url,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/og', undefined, queryParams);
        decoders.GetOGResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listPermissions() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/permissions', undefined, undefined);
        decoders.ListPermissionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getPermission(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/permissions/{id}', pathParams, undefined);
        decoders.GetCustomPermissionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createPoll(request) {
        const body = {
            name: request?.name,
            allow_answers: request?.allow_answers,
            allow_user_suggested_options: request?.allow_user_suggested_options,
            description: request?.description,
            enforce_unique_vote: request?.enforce_unique_vote,
            id: request?.id,
            is_closed: request?.is_closed,
            max_votes_allowed: request?.max_votes_allowed,
            user_id: request?.user_id,
            voting_visibility: request?.voting_visibility,
            options: request?.options,
            custom: request?.custom,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/polls', undefined, undefined, body, 'application/json');
        decoders.PollResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updatePoll(request) {
        const body = {
            id: request?.id,
            name: request?.name,
            allow_answers: request?.allow_answers,
            allow_user_suggested_options: request?.allow_user_suggested_options,
            description: request?.description,
            enforce_unique_vote: request?.enforce_unique_vote,
            is_closed: request?.is_closed,
            max_votes_allowed: request?.max_votes_allowed,
            user_id: request?.user_id,
            voting_visibility: request?.voting_visibility,
            options: request?.options,
            custom: request?.custom,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/polls', undefined, undefined, body, 'application/json');
        decoders.PollResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryPolls(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/polls/query', undefined, queryParams, body, 'application/json');
        decoders.QueryPollsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deletePoll(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            poll_id: request?.poll_id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/polls/{poll_id}', pathParams, queryParams);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getPoll(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            poll_id: request?.poll_id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/polls/{poll_id}', pathParams, queryParams);
        decoders.PollResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updatePollPartial(request) {
        const pathParams = {
            poll_id: request?.poll_id,
        };
        const body = {
            user_id: request?.user_id,
            unset: request?.unset,
            set: request?.set,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/polls/{poll_id}', pathParams, undefined, body, 'application/json');
        decoders.PollResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createPollOption(request) {
        const pathParams = {
            poll_id: request?.poll_id,
        };
        const body = {
            text: request?.text,
            user_id: request?.user_id,
            custom: request?.custom,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/polls/{poll_id}/options', pathParams, undefined, body, 'application/json');
        decoders.PollOptionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updatePollOption(request) {
        const pathParams = {
            poll_id: request?.poll_id,
        };
        const body = {
            id: request?.id,
            text: request?.text,
            user_id: request?.user_id,
            custom: request?.custom,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/polls/{poll_id}/options', pathParams, undefined, body, 'application/json');
        decoders.PollOptionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deletePollOption(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            poll_id: request?.poll_id,
            option_id: request?.option_id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/polls/{poll_id}/options/{option_id}', pathParams, queryParams);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getPollOption(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            poll_id: request?.poll_id,
            option_id: request?.option_id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/polls/{poll_id}/options/{option_id}', pathParams, queryParams);
        decoders.PollOptionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryPollVotes(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            poll_id: request?.poll_id,
        };
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/polls/{poll_id}/votes', pathParams, queryParams, body, 'application/json');
        decoders.PollVotesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updatePushNotificationPreferences(request) {
        const body = {
            preferences: request?.preferences,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/push_preferences', undefined, undefined, body, 'application/json');
        decoders.UpsertPushPreferencesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listPushProviders() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/push_providers', undefined, undefined);
        decoders.ListPushProvidersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async upsertPushProvider(request) {
        const body = {
            push_provider: request?.push_provider,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/push_providers', undefined, undefined, body, 'application/json');
        decoders.UpsertPushProviderResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deletePushProvider(request) {
        const pathParams = {
            type: request?.type,
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/push_providers/{type}/{name}', pathParams, undefined);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getPushTemplates(request) {
        const queryParams = {
            push_provider_type: request?.push_provider_type,
            push_provider_name: request?.push_provider_name,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/push_templates', undefined, queryParams);
        decoders.GetPushTemplatesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async upsertPushTemplate(request) {
        const body = {
            event_type: request?.event_type,
            push_provider_type: request?.push_provider_type,
            enable_push: request?.enable_push,
            push_provider_name: request?.push_provider_name,
            template: request?.template,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/push_templates', undefined, undefined, body, 'application/json');
        decoders.UpsertPushTemplateResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getRateLimits(request) {
        const queryParams = {
            server_side: request?.server_side,
            android: request?.android,
            ios: request?.ios,
            web: request?.web,
            endpoints: request?.endpoints,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/rate_limits', undefined, queryParams);
        decoders.GetRateLimitsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listRoles() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/roles', undefined, undefined);
        decoders.ListRolesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createRole(request) {
        const body = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/roles', undefined, undefined, body, 'application/json');
        decoders.CreateRoleResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteRole(request) {
        const pathParams = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/roles/{name}', pathParams, undefined);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getTask(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/tasks/{id}', pathParams, undefined);
        decoders.GetTaskResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteFile(request) {
        const queryParams = {
            url: request?.url,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/uploads/file', undefined, queryParams);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async uploadFile(request) {
        const body = {
            file: request?.file,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/uploads/file', undefined, undefined, body, 'multipart/form-data');
        decoders.FileUploadResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteImage(request) {
        const queryParams = {
            url: request?.url,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/uploads/image', undefined, queryParams);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async uploadImage(request) {
        const body = {
            file: request?.file,
            upload_sizes: request?.upload_sizes,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/uploads/image', undefined, undefined, body, 'multipart/form-data');
        decoders.ImageUploadResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryUsers(request) {
        const queryParams = {
            payload: request?.payload,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/users', undefined, queryParams);
        decoders.QueryUsersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateUsersPartial(request) {
        const body = {
            users: request?.users,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/users', undefined, undefined, body, 'application/json');
        decoders.UpdateUsersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateUsers(request) {
        const body = {
            users: request?.users,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/users', undefined, undefined, body, 'application/json');
        decoders.UpdateUsersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getBlockedUsers(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/users/block', undefined, queryParams);
        decoders.GetBlockedUsersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async blockUsers(request) {
        const body = {
            blocked_user_id: request?.blocked_user_id,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/users/block', undefined, undefined, body, 'application/json');
        decoders.BlockUsersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deactivateUsers(request) {
        const body = {
            user_ids: request?.user_ids,
            created_by_id: request?.created_by_id,
            mark_channels_deleted: request?.mark_channels_deleted,
            mark_messages_deleted: request?.mark_messages_deleted,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/users/deactivate', undefined, undefined, body, 'application/json');
        decoders.DeactivateUsersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteUsers(request) {
        const body = {
            user_ids: request?.user_ids,
            calls: request?.calls,
            conversations: request?.conversations,
            files: request?.files,
            messages: request?.messages,
            new_call_owner_id: request?.new_call_owner_id,
            new_channel_owner_id: request?.new_channel_owner_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/users/delete', undefined, undefined, body, 'application/json');
        decoders.DeleteUsersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getUserLiveLocations(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/users/live_locations', undefined, queryParams);
        decoders.SharedLocationsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateLiveLocation(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const body = {
            message_id: request?.message_id,
            end_at: request?.end_at,
            latitude: request?.latitude,
            longitude: request?.longitude,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/users/live_locations', undefined, queryParams, body, 'application/json');
        decoders.SharedLocationResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async reactivateUsers(request) {
        const body = {
            user_ids: request?.user_ids,
            created_by_id: request?.created_by_id,
            restore_channels: request?.restore_channels,
            restore_messages: request?.restore_messages,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/users/reactivate', undefined, undefined, body, 'application/json');
        decoders.ReactivateUsersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async restoreUsers(request) {
        const body = {
            user_ids: request?.user_ids,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/users/restore', undefined, undefined, body, 'application/json');
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async unblockUsers(request) {
        const body = {
            blocked_user_id: request?.blocked_user_id,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/users/unblock', undefined, undefined, body, 'application/json');
        decoders.UnblockUsersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deactivateUser(request) {
        const pathParams = {
            user_id: request?.user_id,
        };
        const body = {
            created_by_id: request?.created_by_id,
            mark_messages_deleted: request?.mark_messages_deleted,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/users/{user_id}/deactivate', pathParams, undefined, body, 'application/json');
        decoders.DeactivateUserResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async exportUser(request) {
        const pathParams = {
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/users/{user_id}/export', pathParams, undefined);
        decoders.ExportUserResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async reactivateUser(request) {
        const pathParams = {
            user_id: request?.user_id,
        };
        const body = {
            created_by_id: request?.created_by_id,
            name: request?.name,
            restore_messages: request?.restore_messages,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/users/{user_id}/reactivate', pathParams, undefined, body, 'application/json');
        decoders.ReactivateUserResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
}

class VideoApi {
    constructor(apiClient) {
        this.apiClient = apiClient;
    }
    async getActiveCallsStatus() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/active_calls_status', undefined, undefined);
        decoders.GetActiveCallsStatusResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryUserFeedback(request) {
        const queryParams = {
            full: request?.full,
        };
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter_conditions: request?.filter_conditions,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/feedback', undefined, queryParams, body, 'application/json');
        decoders.QueryUserFeedbackResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryCallMembers(request) {
        const body = {
            id: request?.id,
            type: request?.type,
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter_conditions: request?.filter_conditions,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/members', undefined, undefined, body, 'application/json');
        decoders.QueryCallMembersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryCallStats(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter_conditions: request?.filter_conditions,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/stats', undefined, undefined, body, 'application/json');
        decoders.QueryCallStatsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getCall(request) {
        const queryParams = {
            members_limit: request?.members_limit,
            ring: request?.ring,
            notify: request?.notify,
            video: request?.video,
        };
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/call/{type}/{id}', pathParams, queryParams);
        decoders.GetCallResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateCall(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            starts_at: request?.starts_at,
            custom: request?.custom,
            settings_override: request?.settings_override,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/video/call/{type}/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateCallResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getOrCreateCall(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            members_limit: request?.members_limit,
            notify: request?.notify,
            ring: request?.ring,
            video: request?.video,
            data: request?.data,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}', pathParams, undefined, body, 'application/json');
        decoders.GetOrCreateCallResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async blockUser(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/block', pathParams, undefined, body, 'application/json');
        decoders.BlockUserResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async sendClosedCaption(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            speaker_id: request?.speaker_id,
            text: request?.text,
            end_time: request?.end_time,
            language: request?.language,
            service: request?.service,
            start_time: request?.start_time,
            translated: request?.translated,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/closed_captions', pathParams, undefined, body, 'application/json');
        decoders.SendClosedCaptionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteCall(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            hard: request?.hard,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/delete', pathParams, undefined, body, 'application/json');
        decoders.DeleteCallResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async sendCallEvent(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            user_id: request?.user_id,
            custom: request?.custom,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/event', pathParams, undefined, body, 'application/json');
        decoders.SendCallEventResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async collectUserFeedback(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            rating: request?.rating,
            sdk: request?.sdk,
            sdk_version: request?.sdk_version,
            reason: request?.reason,
            user_session_id: request?.user_session_id,
            custom: request?.custom,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/feedback', pathParams, undefined, body, 'application/json');
        decoders.CollectUserFeedbackResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async goLive(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            recording_storage_name: request?.recording_storage_name,
            start_closed_caption: request?.start_closed_caption,
            start_hls: request?.start_hls,
            start_recording: request?.start_recording,
            start_transcription: request?.start_transcription,
            transcription_storage_name: request?.transcription_storage_name,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/go_live', pathParams, undefined, body, 'application/json');
        decoders.GoLiveResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async kickUser(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            user_id: request?.user_id,
            block: request?.block,
            kicked_by_id: request?.kicked_by_id,
            kicked_by: request?.kicked_by,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/kick', pathParams, undefined, body, 'application/json');
        decoders.KickUserResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async endCall(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/mark_ended', pathParams, undefined);
        decoders.EndCallResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateCallMembers(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            remove_members: request?.remove_members,
            update_members: request?.update_members,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/members', pathParams, undefined, body, 'application/json');
        decoders.UpdateCallMembersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async muteUsers(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            audio: request?.audio,
            mute_all_users: request?.mute_all_users,
            muted_by_id: request?.muted_by_id,
            screenshare: request?.screenshare,
            screenshare_audio: request?.screenshare_audio,
            video: request?.video,
            user_ids: request?.user_ids,
            muted_by: request?.muted_by,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/mute_users', pathParams, undefined, body, 'application/json');
        decoders.MuteUsersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryCallParticipants(request) {
        const queryParams = {
            limit: request?.limit,
        };
        const pathParams = {
            id: request?.id,
            type: request?.type,
        };
        const body = {
            filter_conditions: request?.filter_conditions,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/participants', pathParams, queryParams, body, 'application/json');
        decoders.QueryCallParticipantsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async videoPin(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            session_id: request?.session_id,
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/pin', pathParams, undefined, body, 'application/json');
        decoders.PinResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listRecordings(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/call/{type}/{id}/recordings', pathParams, undefined);
        decoders.ListRecordingsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getCallReport(request) {
        const queryParams = {
            session_id: request?.session_id,
        };
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/call/{type}/{id}/report', pathParams, queryParams);
        decoders.GetCallReportResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async ringCall(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            video: request?.video,
            members_ids: request?.members_ids,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/ring', pathParams, undefined, body, 'application/json');
        decoders.RingCallResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async startRTMPBroadcasts(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            broadcasts: request?.broadcasts,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/rtmp_broadcasts', pathParams, undefined, body, 'application/json');
        decoders.StartRTMPBroadcastsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async stopAllRTMPBroadcasts(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/rtmp_broadcasts/stop', pathParams, undefined);
        decoders.StopAllRTMPBroadcastsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async stopRTMPBroadcast(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
            name: request?.name,
        };
        const body = {};
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/rtmp_broadcasts/{name}/stop', pathParams, undefined, body, 'application/json');
        decoders.StopRTMPBroadcastsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async startHLSBroadcasting(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/start_broadcasting', pathParams, undefined);
        decoders.StartHLSBroadcastingResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async startClosedCaptions(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            enable_transcription: request?.enable_transcription,
            external_storage: request?.external_storage,
            language: request?.language,
            speech_segment_config: request?.speech_segment_config,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/start_closed_captions', pathParams, undefined, body, 'application/json');
        decoders.StartClosedCaptionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async startFrameRecording(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            recording_external_storage: request?.recording_external_storage,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/start_frame_recording', pathParams, undefined, body, 'application/json');
        decoders.StartFrameRecordingResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async startRecording(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            recording_external_storage: request?.recording_external_storage,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/start_recording', pathParams, undefined, body, 'application/json');
        decoders.StartRecordingResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async startTranscription(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            enable_closed_captions: request?.enable_closed_captions,
            language: request?.language,
            transcription_external_storage: request?.transcription_external_storage,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/start_transcription', pathParams, undefined, body, 'application/json');
        decoders.StartTranscriptionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async stopHLSBroadcasting(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/stop_broadcasting', pathParams, undefined);
        decoders.StopHLSBroadcastingResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async stopClosedCaptions(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            stop_transcription: request?.stop_transcription,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/stop_closed_captions', pathParams, undefined, body, 'application/json');
        decoders.StopClosedCaptionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async stopFrameRecording(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/stop_frame_recording', pathParams, undefined);
        decoders.StopFrameRecordingResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async stopLive(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            continue_closed_caption: request?.continue_closed_caption,
            continue_hls: request?.continue_hls,
            continue_recording: request?.continue_recording,
            continue_rtmp_broadcasts: request?.continue_rtmp_broadcasts,
            continue_transcription: request?.continue_transcription,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/stop_live', pathParams, undefined, body, 'application/json');
        decoders.StopLiveResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async stopRecording(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/stop_recording', pathParams, undefined);
        decoders.StopRecordingResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async stopTranscription(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            stop_closed_captions: request?.stop_closed_captions,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/stop_transcription', pathParams, undefined, body, 'application/json');
        decoders.StopTranscriptionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listTranscriptions(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/call/{type}/{id}/transcriptions', pathParams, undefined);
        decoders.ListTranscriptionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async unblockUser(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/unblock', pathParams, undefined, body, 'application/json');
        decoders.UnblockUserResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async videoUnpin(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            session_id: request?.session_id,
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/unpin', pathParams, undefined, body, 'application/json');
        decoders.UnpinResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateUserPermissions(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            user_id: request?.user_id,
            grant_permissions: request?.grant_permissions,
            revoke_permissions: request?.revoke_permissions,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/call/{type}/{id}/user_permissions', pathParams, undefined, body, 'application/json');
        decoders.UpdateUserPermissionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteRecording(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
            session: request?.session,
            filename: request?.filename,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/video/call/{type}/{id}/{session}/recordings/{filename}', pathParams, undefined);
        decoders.DeleteRecordingResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteTranscription(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
            session: request?.session,
            filename: request?.filename,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/video/call/{type}/{id}/{session}/transcriptions/{filename}', pathParams, undefined);
        decoders.DeleteTranscriptionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getCallSessionParticipantStatsDetails(request) {
        const queryParams = {
            since: request?.since,
            until: request?.until,
            max_points: request?.max_points,
        };
        const pathParams = {
            call_type: request?.call_type,
            call_id: request?.call_id,
            session: request?.session,
            user: request?.user,
            user_session: request?.user_session,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/call_stats/{call_type}/{call_id}/{session}/participant/{user}/{user_session}/details', pathParams, queryParams);
        decoders.GetCallSessionParticipantStatsDetailsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryCallSessionParticipantStats(request) {
        const queryParams = {
            sort: request?.sort,
            filter_conditions: request?.filter_conditions,
        };
        const pathParams = {
            call_type: request?.call_type,
            call_id: request?.call_id,
            session: request?.session,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/call_stats/{call_type}/{call_id}/{session}/participants', pathParams, queryParams);
        decoders.QueryCallSessionParticipantStatsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getCallSessionParticipantStatsTimeline(request) {
        const queryParams = {
            start_time: request?.start_time,
            end_time: request?.end_time,
            severity: request?.severity,
        };
        const pathParams = {
            call_type: request?.call_type,
            call_id: request?.call_id,
            session: request?.session,
            user: request?.user,
            user_session: request?.user_session,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/call_stats/{call_type}/{call_id}/{session}/participants/{user}/{user_session}/timeline', pathParams, queryParams);
        decoders.QueryCallSessionParticipantStatsTimelineResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryCalls(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter_conditions: request?.filter_conditions,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/calls', undefined, undefined, body, 'application/json');
        decoders.QueryCallsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listCallTypes() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/calltypes', undefined, undefined);
        decoders.ListCallTypeResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createCallType(request) {
        const body = {
            name: request?.name,
            external_storage: request?.external_storage,
            grants: request?.grants,
            notification_settings: request?.notification_settings,
            settings: request?.settings,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/calltypes', undefined, undefined, body, 'application/json');
        decoders.CreateCallTypeResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteCallType(request) {
        const pathParams = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/video/calltypes/{name}', pathParams, undefined);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getCallType(request) {
        const pathParams = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/calltypes/{name}', pathParams, undefined);
        decoders.GetCallTypeResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateCallType(request) {
        const pathParams = {
            name: request?.name,
        };
        const body = {
            external_storage: request?.external_storage,
            grants: request?.grants,
            notification_settings: request?.notification_settings,
            settings: request?.settings,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/video/calltypes/{name}', pathParams, undefined, body, 'application/json');
        decoders.UpdateCallTypeResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getEdges() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/edges', undefined, undefined);
        decoders.GetEdgesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async resolveSipInbound(request) {
        const body = {
            sip_caller_number: request?.sip_caller_number,
            sip_trunk_number: request?.sip_trunk_number,
            challenge: request?.challenge,
            sip_headers: request?.sip_headers,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/sip/resolve', undefined, undefined, body, 'application/json');
        decoders.ResolveSipInboundResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listSIPInboundRoutingRule() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/sip/routing_rules', undefined, undefined);
        decoders.ListSIPInboundRoutingRuleResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createSIPInboundRoutingRule(request) {
        const body = {
            name: request?.name,
            trunk_ids: request?.trunk_ids,
            caller_configs: request?.caller_configs,
            called_numbers: request?.called_numbers,
            caller_numbers: request?.caller_numbers,
            call_configs: request?.call_configs,
            direct_routing_configs: request?.direct_routing_configs,
            pin_protection_configs: request?.pin_protection_configs,
            pin_routing_configs: request?.pin_routing_configs,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/sip/routing_rules', undefined, undefined, body, 'application/json');
        decoders.SIPInboundRoutingRuleResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteSIPInboundRoutingRule(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/video/sip/routing_rules/{id}', pathParams, undefined);
        decoders.DeleteSIPInboundRoutingRuleResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateSIPInboundRoutingRule(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            name: request?.name,
            called_numbers: request?.called_numbers,
            trunk_ids: request?.trunk_ids,
            caller_configs: request?.caller_configs,
            caller_numbers: request?.caller_numbers,
            call_configs: request?.call_configs,
            direct_routing_configs: request?.direct_routing_configs,
            pin_protection_configs: request?.pin_protection_configs,
            pin_routing_configs: request?.pin_routing_configs,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/video/sip/routing_rules/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateSIPInboundRoutingRuleResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listSIPTrunks() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/video/sip/trunks', undefined, undefined);
        decoders.ListSIPTrunksResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createSIPTrunk(request) {
        const body = {
            name: request?.name,
            numbers: request?.numbers,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/sip/trunks', undefined, undefined, body, 'application/json');
        decoders.CreateSIPTrunkResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteSIPTrunk(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/video/sip/trunks/{id}', pathParams, undefined);
        decoders.DeleteSIPTrunkResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateSIPTrunk(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            name: request?.name,
            numbers: request?.numbers,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/video/sip/trunks/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateSIPTrunkResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryAggregateCallStats(request) {
        const body = {
            from: request?.from,
            to: request?.to,
            report_types: request?.report_types,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/video/stats', undefined, undefined, body, 'application/json');
        decoders.QueryAggregateCallStatsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
}

class CallApi {
    constructor(videoApi, type, id) {
        this.videoApi = videoApi;
        this.type = type;
        this.id = id;
    }
    get(request) {
        return this.videoApi.getCall({ id: this.id, type: this.type, ...request });
    }
    update(request) {
        return this.videoApi.updateCall({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    getOrCreate(request) {
        return this.videoApi.getOrCreateCall({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    blockUser(request) {
        return this.videoApi.blockUser({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    sendClosedCaption(request) {
        return this.videoApi.sendClosedCaption({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    delete(request) {
        return this.videoApi.deleteCall({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    sendCallEvent(request) {
        return this.videoApi.sendCallEvent({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    collectUserFeedback(request) {
        return this.videoApi.collectUserFeedback({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    goLive(request) {
        return this.videoApi.goLive({ id: this.id, type: this.type, ...request });
    }
    kickUser(request) {
        return this.videoApi.kickUser({ id: this.id, type: this.type, ...request });
    }
    end() {
        return this.videoApi.endCall({ id: this.id, type: this.type });
    }
    updateCallMembers(request) {
        return this.videoApi.updateCallMembers({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    muteUsers(request) {
        return this.videoApi.muteUsers({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    queryCallParticipants(request) {
        return this.videoApi.queryCallParticipants({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    videoPin(request) {
        return this.videoApi.videoPin({ id: this.id, type: this.type, ...request });
    }
    listRecordings() {
        return this.videoApi.listRecordings({ id: this.id, type: this.type });
    }
    getCallReport(request) {
        return this.videoApi.getCallReport({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    ring(request) {
        return this.videoApi.ringCall({ id: this.id, type: this.type, ...request });
    }
    startRTMPBroadcasts(request) {
        return this.videoApi.startRTMPBroadcasts({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    stopAllRTMPBroadcasts() {
        return this.videoApi.stopAllRTMPBroadcasts({
            id: this.id,
            type: this.type,
        });
    }
    stopRTMPBroadcast(request) {
        return this.videoApi.stopRTMPBroadcast({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    startHLSBroadcasting() {
        return this.videoApi.startHLSBroadcasting({ id: this.id, type: this.type });
    }
    startClosedCaptions(request) {
        return this.videoApi.startClosedCaptions({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    startFrameRecording(request) {
        return this.videoApi.startFrameRecording({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    startRecording(request) {
        return this.videoApi.startRecording({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    startTranscription(request) {
        return this.videoApi.startTranscription({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    stopHLSBroadcasting() {
        return this.videoApi.stopHLSBroadcasting({ id: this.id, type: this.type });
    }
    stopClosedCaptions(request) {
        return this.videoApi.stopClosedCaptions({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    stopFrameRecording() {
        return this.videoApi.stopFrameRecording({ id: this.id, type: this.type });
    }
    stopLive(request) {
        return this.videoApi.stopLive({ id: this.id, type: this.type, ...request });
    }
    stopRecording() {
        return this.videoApi.stopRecording({ id: this.id, type: this.type });
    }
    stopTranscription(request) {
        return this.videoApi.stopTranscription({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    listTranscriptions() {
        return this.videoApi.listTranscriptions({ id: this.id, type: this.type });
    }
    unblockUser(request) {
        return this.videoApi.unblockUser({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    videoUnpin(request) {
        return this.videoApi.videoUnpin({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    updateUserPermissions(request) {
        return this.videoApi.updateUserPermissions({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    deleteRecording(request) {
        return this.videoApi.deleteRecording({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    deleteTranscription(request) {
        return this.videoApi.deleteTranscription({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
}

class StreamCall extends CallApi {
    constructor(videoApi, type, id, streamClient) {
        super(videoApi, type, id);
        this.type = type;
        this.id = id;
        this.streamClient = streamClient;
        this.create = (request) => this.getOrCreate(request);
        this.queryMembers = (request) => {
            return this.videoApi.queryCallMembers({
                id: this.id,
                type: this.type,
                ...(request ?? {}),
            });
        };
        this.getOrCreate = async (request) => {
            const response = await super.getOrCreate(request);
            this.data = response.call;
            return response;
        };
        this.get = async () => {
            const response = await super.get();
            this.data = response.call;
            return response;
        };
        this.createSRTCredentials = (userID) => {
            if (!this.data) {
                throw new Error('Object is not initialized, call get() or getOrCreate() first');
            }
            const token = this.streamClient.generatePermanentUserToken({
                user_id: userID,
            });
            const segments = token.split('.');
            if (segments.length !== 3) {
                throw new Error('Invalid token format');
            }
            return {
                address: this.data.ingress.srt.address
                    .replace('{passphrase}', segments[2])
                    .replace('{token}', token),
            };
        };
    }
    get cid() {
        return `${this.type}:${this.id}`;
    }
}

class StreamVideoClient extends VideoApi {
    constructor({ streamClient, apiClient, }) {
        super(apiClient);
        this.call = (type, id) => {
            return new StreamCall(this, type, id, this.streamClient);
        };
        this.connectOpenAi = async (options) => {
            let doCreateRealtimeClient;
            try {
                doCreateRealtimeClient = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('@stream-io/openai-realtime-api')); }))
                    .createRealtimeClient;
            }
            catch {
                throw new Error('Cannot create Realtime API client. Is @stream-io/openai-realtime-api installed?');
            }
            if (!options.agentUserId) {
                throw new Error('"agentUserId" must by specified in options');
            }
            const token = this.streamClient.generateCallToken({
                user_id: options.agentUserId,
                call_cids: [options.call.cid],
                validity_in_seconds: options.validityInSeconds,
            });
            const realtimeClient = doCreateRealtimeClient({
                baseUrl: this.streamClient.apiClient.apiConfig.baseUrl,
                call: options.call,
                streamApiKey: this.streamClient.apiClient.apiConfig.apiKey,
                streamUserToken: token,
                openAiApiKey: options.openAiApiKey,
                model: options.model,
            });
            await realtimeClient.connect();
            return realtimeClient;
        };
        this.streamClient = streamClient;
    }
}

class ChatApi {
    constructor(apiClient) {
        this.apiClient = apiClient;
    }
    async queryCampaigns(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            user_limit: request?.user_limit,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/campaigns/query', undefined, undefined, body, 'application/json');
        decoders.QueryCampaignsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getCampaign(request) {
        const queryParams = {
            prev: request?.prev,
            next: request?.next,
            limit: request?.limit,
        };
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/campaigns/{id}', pathParams, queryParams);
        decoders.GetCampaignResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async startCampaign(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            scheduled_for: request?.scheduled_for,
            stop_at: request?.stop_at,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/campaigns/{id}/start', pathParams, undefined, body, 'application/json');
        decoders.StartCampaignResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async scheduleCampaign(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {};
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/campaigns/{id}/stop', pathParams, undefined, body, 'application/json');
        decoders.CampaignResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryChannels(request) {
        const body = {
            limit: request?.limit,
            member_limit: request?.member_limit,
            message_limit: request?.message_limit,
            offset: request?.offset,
            state: request?.state,
            user_id: request?.user_id,
            sort: request?.sort,
            filter_conditions: request?.filter_conditions,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels', undefined, undefined, body, 'application/json');
        decoders.QueryChannelsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteChannels(request) {
        const body = {
            cids: request?.cids,
            hard_delete: request?.hard_delete,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/delete', undefined, undefined, body, 'application/json');
        decoders.DeleteChannelsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async markDelivered(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const body = {
            latest_delivered_messages: request?.latest_delivered_messages,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/delivered', undefined, queryParams, body, 'application/json');
        decoders.MarkDeliveredResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async markChannelsRead(request) {
        const body = {
            user_id: request?.user_id,
            read_by_channel: request?.read_by_channel,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/read', undefined, undefined, body, 'application/json');
        decoders.MarkReadResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getOrCreateDistinctChannel(request) {
        const pathParams = {
            type: request?.type,
        };
        const body = {
            hide_for_creator: request?.hide_for_creator,
            state: request?.state,
            thread_unread_counts: request?.thread_unread_counts,
            data: request?.data,
            members: request?.members,
            messages: request?.messages,
            watchers: request?.watchers,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/{type}/query', pathParams, undefined, body, 'application/json');
        decoders.ChannelStateResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteChannel(request) {
        const queryParams = {
            hard_delete: request?.hard_delete,
        };
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/chat/channels/{type}/{id}', pathParams, queryParams);
        decoders.DeleteChannelResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateChannelPartial(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            user_id: request?.user_id,
            unset: request?.unset,
            set: request?.set,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/chat/channels/{type}/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateChannelPartialResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateChannel(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            accept_invite: request?.accept_invite,
            cooldown: request?.cooldown,
            hide_history: request?.hide_history,
            hide_history_before: request?.hide_history_before,
            reject_invite: request?.reject_invite,
            skip_push: request?.skip_push,
            user_id: request?.user_id,
            add_filter_tags: request?.add_filter_tags,
            add_members: request?.add_members,
            add_moderators: request?.add_moderators,
            assign_roles: request?.assign_roles,
            demote_moderators: request?.demote_moderators,
            invites: request?.invites,
            remove_filter_tags: request?.remove_filter_tags,
            remove_members: request?.remove_members,
            data: request?.data,
            message: request?.message,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateChannelResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteDraft(request) {
        const queryParams = {
            parent_id: request?.parent_id,
            user_id: request?.user_id,
        };
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/chat/channels/{type}/{id}/draft', pathParams, queryParams);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getDraft(request) {
        const queryParams = {
            parent_id: request?.parent_id,
            user_id: request?.user_id,
        };
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/channels/{type}/{id}/draft', pathParams, queryParams);
        decoders.GetDraftResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async sendEvent(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            event: request?.event,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/event', pathParams, undefined, body, 'application/json');
        decoders.EventResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteChannelFile(request) {
        const queryParams = {
            url: request?.url,
        };
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/chat/channels/{type}/{id}/file', pathParams, queryParams);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async uploadChannelFile(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            file: request?.file,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/file', pathParams, undefined, body, 'multipart/form-data');
        decoders.UploadChannelFileResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async hideChannel(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            clear_history: request?.clear_history,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/hide', pathParams, undefined, body, 'application/json');
        decoders.HideChannelResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteChannelImage(request) {
        const queryParams = {
            url: request?.url,
        };
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/chat/channels/{type}/{id}/image', pathParams, queryParams);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async uploadChannelImage(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            file: request?.file,
            upload_sizes: request?.upload_sizes,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/image', pathParams, undefined, body, 'multipart/form-data');
        decoders.UploadChannelResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateMemberPartial(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            unset: request?.unset,
            set: request?.set,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/chat/channels/{type}/{id}/member', pathParams, queryParams, body, 'application/json');
        decoders.UpdateMemberPartialResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async sendMessage(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            message: request?.message,
            force_moderation: request?.force_moderation,
            keep_channel_hidden: request?.keep_channel_hidden,
            pending: request?.pending,
            skip_enrich_url: request?.skip_enrich_url,
            skip_push: request?.skip_push,
            pending_message_metadata: request?.pending_message_metadata,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/message', pathParams, undefined, body, 'application/json');
        decoders.SendMessageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getManyMessages(request) {
        const queryParams = {
            ids: request?.ids,
        };
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/channels/{type}/{id}/messages', pathParams, queryParams);
        decoders.GetManyMessagesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getOrCreateChannel(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            hide_for_creator: request?.hide_for_creator,
            state: request?.state,
            thread_unread_counts: request?.thread_unread_counts,
            data: request?.data,
            members: request?.members,
            messages: request?.messages,
            watchers: request?.watchers,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/query', pathParams, undefined, body, 'application/json');
        decoders.ChannelStateResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async markRead(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            message_id: request?.message_id,
            thread_id: request?.thread_id,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/read', pathParams, undefined, body, 'application/json');
        decoders.MarkReadResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async showChannel(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/show', pathParams, undefined, body, 'application/json');
        decoders.ShowChannelResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async truncateChannel(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            hard_delete: request?.hard_delete,
            skip_push: request?.skip_push,
            truncated_at: request?.truncated_at,
            user_id: request?.user_id,
            member_ids: request?.member_ids,
            message: request?.message,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/truncate', pathParams, undefined, body, 'application/json');
        decoders.TruncateChannelResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async markUnread(request) {
        const pathParams = {
            type: request?.type,
            id: request?.id,
        };
        const body = {
            message_id: request?.message_id,
            message_timestamp: request?.message_timestamp,
            thread_id: request?.thread_id,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/unread', pathParams, undefined, body, 'application/json');
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listChannelTypes() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/channeltypes', undefined, undefined);
        decoders.ListChannelTypesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createChannelType(request) {
        const body = {
            automod: request?.automod,
            automod_behavior: request?.automod_behavior,
            max_message_length: request?.max_message_length,
            name: request?.name,
            blocklist: request?.blocklist,
            blocklist_behavior: request?.blocklist_behavior,
            connect_events: request?.connect_events,
            count_messages: request?.count_messages,
            custom_events: request?.custom_events,
            delivery_events: request?.delivery_events,
            mark_messages_pending: request?.mark_messages_pending,
            message_retention: request?.message_retention,
            mutes: request?.mutes,
            partition_size: request?.partition_size,
            partition_ttl: request?.partition_ttl,
            polls: request?.polls,
            push_notifications: request?.push_notifications,
            reactions: request?.reactions,
            read_events: request?.read_events,
            replies: request?.replies,
            search: request?.search,
            shared_locations: request?.shared_locations,
            skip_last_msg_update_for_system_msgs: request?.skip_last_msg_update_for_system_msgs,
            typing_events: request?.typing_events,
            uploads: request?.uploads,
            url_enrichment: request?.url_enrichment,
            user_message_reminders: request?.user_message_reminders,
            blocklists: request?.blocklists,
            commands: request?.commands,
            permissions: request?.permissions,
            grants: request?.grants,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/channeltypes', undefined, undefined, body, 'application/json');
        decoders.CreateChannelTypeResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteChannelType(request) {
        const pathParams = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/chat/channeltypes/{name}', pathParams, undefined);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getChannelType(request) {
        const pathParams = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/channeltypes/{name}', pathParams, undefined);
        decoders.GetChannelTypeResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateChannelType(request) {
        const pathParams = {
            name: request?.name,
        };
        const body = {
            automod: request?.automod,
            automod_behavior: request?.automod_behavior,
            max_message_length: request?.max_message_length,
            blocklist: request?.blocklist,
            blocklist_behavior: request?.blocklist_behavior,
            connect_events: request?.connect_events,
            count_messages: request?.count_messages,
            custom_events: request?.custom_events,
            delivery_events: request?.delivery_events,
            mark_messages_pending: request?.mark_messages_pending,
            mutes: request?.mutes,
            partition_size: request?.partition_size,
            partition_ttl: request?.partition_ttl,
            polls: request?.polls,
            push_notifications: request?.push_notifications,
            quotes: request?.quotes,
            reactions: request?.reactions,
            read_events: request?.read_events,
            reminders: request?.reminders,
            replies: request?.replies,
            search: request?.search,
            shared_locations: request?.shared_locations,
            skip_last_msg_update_for_system_msgs: request?.skip_last_msg_update_for_system_msgs,
            typing_events: request?.typing_events,
            uploads: request?.uploads,
            url_enrichment: request?.url_enrichment,
            user_message_reminders: request?.user_message_reminders,
            allowed_flag_reasons: request?.allowed_flag_reasons,
            blocklists: request?.blocklists,
            commands: request?.commands,
            permissions: request?.permissions,
            automod_thresholds: request?.automod_thresholds,
            grants: request?.grants,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/chat/channeltypes/{name}', pathParams, undefined, body, 'application/json');
        decoders.UpdateChannelTypeResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listCommands() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/commands', undefined, undefined);
        decoders.ListCommandsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createCommand(request) {
        const body = {
            description: request?.description,
            name: request?.name,
            args: request?.args,
            set: request?.set,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/commands', undefined, undefined, body, 'application/json');
        decoders.CreateCommandResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteCommand(request) {
        const pathParams = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/chat/commands/{name}', pathParams, undefined);
        decoders.DeleteCommandResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getCommand(request) {
        const pathParams = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/commands/{name}', pathParams, undefined);
        decoders.GetCommandResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateCommand(request) {
        const pathParams = {
            name: request?.name,
        };
        const body = {
            description: request?.description,
            args: request?.args,
            set: request?.set,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/chat/commands/{name}', pathParams, undefined, body, 'application/json');
        decoders.UpdateCommandResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryDrafts(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            user_id: request?.user_id,
            sort: request?.sort,
            filter: request?.filter,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/drafts/query', undefined, undefined, body, 'application/json');
        decoders.QueryDraftsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async exportChannels(request) {
        const body = {
            channels: request?.channels,
            clear_deleted_message_text: request?.clear_deleted_message_text,
            export_users: request?.export_users,
            include_soft_deleted_channels: request?.include_soft_deleted_channels,
            include_truncated_messages: request?.include_truncated_messages,
            version: request?.version,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/export_channels', undefined, undefined, body, 'application/json');
        decoders.ExportChannelsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryMembers(request) {
        const queryParams = {
            payload: request?.payload,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/members', undefined, queryParams);
        decoders.MembersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryMessageHistory(request) {
        const body = {
            filter: request?.filter,
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/messages/history', undefined, undefined, body, 'application/json');
        decoders.QueryMessageHistoryResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteMessage(request) {
        const queryParams = {
            hard: request?.hard,
            deleted_by: request?.deleted_by,
            delete_for_me: request?.delete_for_me,
        };
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/chat/messages/{id}', pathParams, queryParams);
        decoders.DeleteMessageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getMessage(request) {
        const queryParams = {
            show_deleted_message: request?.show_deleted_message,
        };
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/messages/{id}', pathParams, queryParams);
        decoders.GetMessageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateMessage(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            message: request?.message,
            skip_enrich_url: request?.skip_enrich_url,
            skip_push: request?.skip_push,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/messages/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateMessageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateMessagePartial(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            skip_enrich_url: request?.skip_enrich_url,
            user_id: request?.user_id,
            unset: request?.unset,
            set: request?.set,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/chat/messages/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateMessagePartialResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async runMessageAction(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            form_data: request?.form_data,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/messages/{id}/action', pathParams, undefined, body, 'application/json');
        decoders.MessageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async commitMessage(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {};
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/messages/{id}/commit', pathParams, undefined, body, 'application/json');
        decoders.MessageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async ephemeralMessageUpdate(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            skip_enrich_url: request?.skip_enrich_url,
            user_id: request?.user_id,
            unset: request?.unset,
            set: request?.set,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/chat/messages/{id}/ephemeral', pathParams, undefined, body, 'application/json');
        decoders.UpdateMessagePartialResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async sendReaction(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            reaction: request?.reaction,
            enforce_unique: request?.enforce_unique,
            skip_push: request?.skip_push,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/messages/{id}/reaction', pathParams, undefined, body, 'application/json');
        decoders.SendReactionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteReaction(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            id: request?.id,
            type: request?.type,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/chat/messages/{id}/reaction/{type}', pathParams, queryParams);
        decoders.DeleteReactionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getReactions(request) {
        const queryParams = {
            limit: request?.limit,
            offset: request?.offset,
        };
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/messages/{id}/reactions', pathParams, queryParams);
        decoders.GetReactionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryReactions(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            user_id: request?.user_id,
            sort: request?.sort,
            filter: request?.filter,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/messages/{id}/reactions', pathParams, undefined, body, 'application/json');
        decoders.QueryReactionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async translateMessage(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            language: request?.language,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/messages/{id}/translate', pathParams, undefined, body, 'application/json');
        decoders.MessageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async undeleteMessage(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            message: request?.message,
            skip_enrich_url: request?.skip_enrich_url,
            skip_push: request?.skip_push,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/messages/{id}/undelete', pathParams, undefined, body, 'application/json');
        decoders.UpdateMessageResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async castPollVote(request) {
        const pathParams = {
            message_id: request?.message_id,
            poll_id: request?.poll_id,
        };
        const body = {
            user_id: request?.user_id,
            user: request?.user,
            vote: request?.vote,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/messages/{message_id}/polls/{poll_id}/vote', pathParams, undefined, body, 'application/json');
        decoders.PollVoteResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deletePollVote(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            message_id: request?.message_id,
            poll_id: request?.poll_id,
            vote_id: request?.vote_id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/chat/messages/{message_id}/polls/{poll_id}/vote/{vote_id}', pathParams, queryParams);
        decoders.PollVoteResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteReminder(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            message_id: request?.message_id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/chat/messages/{message_id}/reminders', pathParams, queryParams);
        decoders.DeleteReminderResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateReminder(request) {
        const pathParams = {
            message_id: request?.message_id,
        };
        const body = {
            remind_at: request?.remind_at,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/chat/messages/{message_id}/reminders', pathParams, undefined, body, 'application/json');
        decoders.UpdateReminderResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createReminder(request) {
        const pathParams = {
            message_id: request?.message_id,
        };
        const body = {
            remind_at: request?.remind_at,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/messages/{message_id}/reminders', pathParams, undefined, body, 'application/json');
        decoders.ReminderResponseData?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getReplies(request) {
        const queryParams = {
            limit: request?.limit,
            id_gte: request?.id_gte,
            id_gt: request?.id_gt,
            id_lte: request?.id_lte,
            id_lt: request?.id_lt,
            id_around: request?.id_around,
            sort: request?.sort,
        };
        const pathParams = {
            parent_id: request?.parent_id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/messages/{parent_id}/replies', pathParams, queryParams);
        decoders.GetRepliesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryMessageFlags(request) {
        const queryParams = {
            payload: request?.payload,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/moderation/flags/message', undefined, queryParams);
        decoders.QueryMessageFlagsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async muteChannel(request) {
        const body = {
            expiration: request?.expiration,
            user_id: request?.user_id,
            channel_cids: request?.channel_cids,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/moderation/mute/channel', undefined, undefined, body, 'application/json');
        decoders.MuteChannelResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async unmuteChannel(request) {
        const body = {
            expiration: request?.expiration,
            user_id: request?.user_id,
            channel_cids: request?.channel_cids,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/moderation/unmute/channel', undefined, undefined, body, 'application/json');
        decoders.UnmuteResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryBannedUsers(request) {
        const queryParams = {
            payload: request?.payload,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/query_banned_users', undefined, queryParams);
        decoders.QueryBannedUsersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryReminders(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            user_id: request?.user_id,
            sort: request?.sort,
            filter: request?.filter,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/reminders/query', undefined, undefined, body, 'application/json');
        decoders.QueryRemindersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async search(request) {
        const queryParams = {
            payload: request?.payload,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/search', undefined, queryParams);
        decoders.SearchResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async querySegments(request) {
        const body = {
            filter: request?.filter,
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/segments/query', undefined, undefined, body, 'application/json');
        decoders.QuerySegmentsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteSegment(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/chat/segments/{id}', pathParams, undefined);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getSegment(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/segments/{id}', pathParams, undefined);
        decoders.GetSegmentResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteSegmentTargets(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            target_ids: request?.target_ids,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/segments/{id}/deletetargets', pathParams, undefined, body, 'application/json');
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async segmentTargetExists(request) {
        const pathParams = {
            id: request?.id,
            target_id: request?.target_id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/segments/{id}/target/{target_id}', pathParams, undefined);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async querySegmentTargets(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/segments/{id}/targets/query', pathParams, undefined, body, 'application/json');
        decoders.QuerySegmentTargetsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryThreads(request) {
        const body = {
            limit: request?.limit,
            member_limit: request?.member_limit,
            next: request?.next,
            participant_limit: request?.participant_limit,
            prev: request?.prev,
            reply_limit: request?.reply_limit,
            user_id: request?.user_id,
            sort: request?.sort,
            filter: request?.filter,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/threads', undefined, undefined, body, 'application/json');
        decoders.QueryThreadsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getThread(request) {
        const queryParams = {
            reply_limit: request?.reply_limit,
            participant_limit: request?.participant_limit,
            member_limit: request?.member_limit,
        };
        const pathParams = {
            message_id: request?.message_id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/threads/{message_id}', pathParams, queryParams);
        decoders.GetThreadResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateThreadPartial(request) {
        const pathParams = {
            message_id: request?.message_id,
        };
        const body = {
            user_id: request?.user_id,
            unset: request?.unset,
            set: request?.set,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/chat/threads/{message_id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateThreadPartialResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async unreadCounts(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/chat/unread', undefined, queryParams);
        decoders.WrappedUnreadCountsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async unreadCountsBatch(request) {
        const body = {
            user_ids: request?.user_ids,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/unread_batch', undefined, undefined, body, 'application/json');
        decoders.UnreadCountsBatchResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async sendUserCustomEvent(request) {
        const pathParams = {
            user_id: request?.user_id,
        };
        const body = {
            event: request?.event,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/chat/users/{user_id}/event', pathParams, undefined, body, 'application/json');
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
}

class ChannelApi {
    constructor(chatApi, type, id) {
        this.chatApi = chatApi;
        this.type = type;
        this.id = id;
    }
    delete(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.deleteChannel({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    updateChannelPartial(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.updateChannelPartial({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    update(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.updateChannel({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    deleteDraft(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.deleteDraft({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    getDraft(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.getDraft({ id: this.id, type: this.type, ...request });
    }
    sendEvent(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.sendEvent({ id: this.id, type: this.type, ...request });
    }
    deleteChannelFile(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.deleteChannelFile({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    uploadChannelFile(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.uploadChannelFile({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    hide(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.hideChannel({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    deleteChannelImage(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.deleteChannelImage({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    uploadChannelImage(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.uploadChannelImage({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    updateMemberPartial(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.updateMemberPartial({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    sendMessage(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.sendMessage({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    getManyMessages(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.getManyMessages({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    getOrCreate(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.getOrCreateChannel({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    markRead(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.markRead({ id: this.id, type: this.type, ...request });
    }
    show(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.showChannel({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    truncate(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.truncateChannel({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
    markUnread(request) {
        if (!this.id) {
            throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
        }
        return this.chatApi.markUnread({
            id: this.id,
            type: this.type,
            ...request,
        });
    }
}

class StreamChannel extends ChannelApi {
    constructor() {
        super(...arguments);
        this.getOrCreate = (channel_get_or_create_request) => {
            if (!this.id) {
                return this.chatApi
                    .getOrCreateDistinctChannel({
                    type: this.type,
                    ...channel_get_or_create_request,
                })
                    .then((response) => {
                    this.id = response.channel?.id;
                    return response;
                });
            }
            else {
                return this.chatApi.getOrCreateChannel({
                    id: this.id,
                    type: this.type,
                    ...channel_get_or_create_request,
                });
            }
        };
    }
    get cid() {
        return `${this.type}:${this.id}`;
    }
    queryMembers(request) {
        return this.chatApi.queryMembers({
            payload: {
                id: this.id,
                type: this.type,
                ...(request?.payload ?? { filter_conditions: {} }),
            },
        });
    }
}

class StreamChatClient extends ChatApi {
    constructor() {
        super(...arguments);
        this.channel = (type, id) => {
            return new StreamChannel(this, type, id);
        };
    }
}

class ModerationApi {
    constructor(apiClient) {
        this.apiClient = apiClient;
    }
    async ban(request) {
        const body = {
            target_user_id: request?.target_user_id,
            banned_by_id: request?.banned_by_id,
            channel_cid: request?.channel_cid,
            delete_messages: request?.delete_messages,
            ip_ban: request?.ip_ban,
            reason: request?.reason,
            shadow: request?.shadow,
            timeout: request?.timeout,
            banned_by: request?.banned_by,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/ban', undefined, undefined, body, 'application/json');
        decoders.BanResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async bulkImageModeration(request) {
        const body = {
            csv_file: request?.csv_file,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/bulk_image_moderation', undefined, undefined, body, 'application/json');
        decoders.BulkImageModerationResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async check(request) {
        const body = {
            entity_creator_id: request?.entity_creator_id,
            entity_id: request?.entity_id,
            entity_type: request?.entity_type,
            config_key: request?.config_key,
            config_team: request?.config_team,
            test_mode: request?.test_mode,
            user_id: request?.user_id,
            config: request?.config,
            moderation_payload: request?.moderation_payload,
            options: request?.options,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/check', undefined, undefined, body, 'application/json');
        decoders.CheckResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async upsertConfig(request) {
        const body = {
            key: request?.key,
            async: request?.async,
            team: request?.team,
            user_id: request?.user_id,
            ai_image_config: request?.ai_image_config,
            ai_text_config: request?.ai_text_config,
            ai_video_config: request?.ai_video_config,
            automod_platform_circumvention_config: request?.automod_platform_circumvention_config,
            automod_semantic_filters_config: request?.automod_semantic_filters_config,
            automod_toxicity_config: request?.automod_toxicity_config,
            aws_rekognition_config: request?.aws_rekognition_config,
            block_list_config: request?.block_list_config,
            bodyguard_config: request?.bodyguard_config,
            google_vision_config: request?.google_vision_config,
            llm_config: request?.llm_config,
            rule_builder_config: request?.rule_builder_config,
            user: request?.user,
            velocity_filter_config: request?.velocity_filter_config,
            video_call_rule_config: request?.video_call_rule_config,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/config', undefined, undefined, body, 'application/json');
        decoders.UpsertConfigResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteConfig(request) {
        const queryParams = {
            team: request?.team,
        };
        const pathParams = {
            key: request?.key,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/moderation/config/{key}', pathParams, queryParams);
        decoders.DeleteModerationConfigResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getConfig(request) {
        const queryParams = {
            team: request?.team,
        };
        const pathParams = {
            key: request?.key,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/moderation/config/{key}', pathParams, queryParams);
        decoders.GetConfigResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryModerationConfigs(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            user_id: request?.user_id,
            sort: request?.sort,
            filter: request?.filter,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/configs', undefined, undefined, body, 'application/json');
        decoders.QueryModerationConfigsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async customCheck(request) {
        const body = {
            entity_id: request?.entity_id,
            entity_type: request?.entity_type,
            flags: request?.flags,
            entity_creator_id: request?.entity_creator_id,
            user_id: request?.user_id,
            moderation_payload: request?.moderation_payload,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/custom_check', undefined, undefined, body, 'application/json');
        decoders.CustomCheckResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async v2DeleteTemplate() {
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/moderation/feeds_moderation_template', undefined, undefined);
        decoders.DeleteModerationTemplateResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async v2QueryTemplates() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/moderation/feeds_moderation_template', undefined, undefined);
        decoders.QueryFeedModerationTemplatesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async v2UpsertTemplate(request) {
        const body = {
            name: request?.name,
            config: request?.config,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/feeds_moderation_template', undefined, undefined, body, 'application/json');
        decoders.UpsertModerationTemplateResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async flag(request) {
        const body = {
            entity_id: request?.entity_id,
            entity_type: request?.entity_type,
            entity_creator_id: request?.entity_creator_id,
            reason: request?.reason,
            user_id: request?.user_id,
            custom: request?.custom,
            moderation_payload: request?.moderation_payload,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/flag', undefined, undefined, body, 'application/json');
        decoders.FlagResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryModerationFlags(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/flags', undefined, undefined, body, 'application/json');
        decoders.QueryModerationFlagsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryModerationLogs(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            user_id: request?.user_id,
            sort: request?.sort,
            filter: request?.filter,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/logs', undefined, undefined, body, 'application/json');
        decoders.QueryModerationLogsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async upsertModerationRule(request) {
        const body = {
            name: request?.name,
            rule_type: request?.rule_type,
            action: request?.action,
            cooldown_period: request?.cooldown_period,
            description: request?.description,
            enabled: request?.enabled,
            logic: request?.logic,
            team: request?.team,
            conditions: request?.conditions,
            config_keys: request?.config_keys,
            groups: request?.groups,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/moderation_rule', undefined, undefined, body, 'application/json');
        decoders.UpsertModerationRuleResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteModerationRule() {
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/moderation/moderation_rule/{id}', undefined, undefined);
        decoders.DeleteModerationRuleResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getModerationRule() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/moderation/moderation_rule/{id}', undefined, undefined);
        decoders.GetModerationRuleResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryModerationRules(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            user_id: request?.user_id,
            sort: request?.sort,
            filter: request?.filter,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/moderation_rules', undefined, undefined, body, 'application/json');
        decoders.QueryModerationRulesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async mute(request) {
        const body = {
            target_ids: request?.target_ids,
            timeout: request?.timeout,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/mute', undefined, undefined, body, 'application/json');
        decoders.MuteResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryReviewQueue(request) {
        const body = {
            limit: request?.limit,
            lock_count: request?.lock_count,
            lock_duration: request?.lock_duration,
            lock_items: request?.lock_items,
            next: request?.next,
            prev: request?.prev,
            stats_only: request?.stats_only,
            user_id: request?.user_id,
            sort: request?.sort,
            filter: request?.filter,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/review_queue', undefined, undefined, body, 'application/json');
        decoders.QueryReviewQueueResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getReviewQueueItem(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/moderation/review_queue/{id}', pathParams, undefined);
        decoders.GetReviewQueueItemResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async submitAction(request) {
        const body = {
            action_type: request?.action_type,
            item_id: request?.item_id,
            user_id: request?.user_id,
            ban: request?.ban,
            block: request?.block,
            custom: request?.custom,
            delete_activity: request?.delete_activity,
            delete_comment: request?.delete_comment,
            delete_message: request?.delete_message,
            delete_reaction: request?.delete_reaction,
            delete_user: request?.delete_user,
            mark_reviewed: request?.mark_reviewed,
            shadow_block: request?.shadow_block,
            unban: request?.unban,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/submit_action', undefined, undefined, body, 'application/json');
        decoders.SubmitActionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async unban(request) {
        const queryParams = {
            target_user_id: request?.target_user_id,
            channel_cid: request?.channel_cid,
            created_by: request?.created_by,
        };
        const body = {
            unbanned_by_id: request?.unbanned_by_id,
            unbanned_by: request?.unbanned_by,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/unban', undefined, queryParams, body, 'application/json');
        decoders.UnbanResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async unmute(request) {
        const body = {
            target_ids: request?.target_ids,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/moderation/unmute', undefined, undefined, body, 'application/json');
        decoders.UnmuteResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
}

class StreamModerationClient extends ModerationApi {
}

class StreamError extends Error {
    constructor(message, metadata, code, errorOptions) {
        super(message, errorOptions);
        this.metadata = metadata;
        this.code = code;
    }
}

const getRateLimitFromResponseHeader = (responseHeaders) => {
    const rateLimit = responseHeaders.has('x-ratelimit-limit')
        ? +responseHeaders.get('x-ratelimit-limit')
        : undefined;
    const rateLimitRemaining = responseHeaders.has('x-ratelimit-remaining')
        ? +responseHeaders.get('x-ratelimit-remaining')
        : undefined;
    const rateLimitReset = responseHeaders.has('x-ratelimit-reset')
        ? new Date(+responseHeaders.get('x-ratelimit-reset') * 1000)
        : undefined;
    const result = {
        rateLimit,
        rateLimitRemaining,
        rateLimitReset,
    };
    return result;
};

class ApiClient {
    constructor(apiConfig) {
        this.apiConfig = apiConfig;
        /**
         *
         * @internal
         */
        this.sendRequest = async (method, url, pathParams, queryParams, body, requestContentType) => {
            queryParams = queryParams ?? {};
            queryParams.api_key = this.apiConfig.apiKey;
            const encodedParams = this.queryParamsStringify(queryParams);
            if (pathParams) {
                Object.keys(pathParams).forEach((paramName) => {
                    url = url.replace(`{${paramName}}`, pathParams[paramName]);
                });
            }
            url += `?${encodedParams}`;
            const clientRequestId = uuid.v4();
            const headers = {
                Authorization: this.apiConfig.token,
                'stream-auth-type': 'jwt',
                'X-Stream-Client': 'stream-node-' + "0.7.21",
                'Accept-Encoding': 'gzip',
                'x-client-request-id': clientRequestId,
            };
            // https://stackoverflow.com/questions/39280438/fetch-missing-boundary-in-multipart-form-data-post
            if (requestContentType !== 'multipart/form-data') {
                headers['Content-Type'] = requestContentType ?? 'application/json';
            }
            const signal = AbortSignal.timeout(this.apiConfig.timeout);
            const encodedBody = requestContentType === 'multipart/form-data'
                ? new FormData()
                : JSON.stringify(body);
            if (requestContentType === 'multipart/form-data') {
                Object.keys(body).forEach((key) => {
                    encodedBody.append(key, body[key]);
                });
            }
            try {
                const response = await fetch(`${this.apiConfig.baseUrl}${url}`, {
                    signal: requestContentType === 'multipart/form-data' ? undefined : signal,
                    method,
                    body: encodedBody,
                    headers,
                    dispatcher: this.dispatcher,
                });
                const responseHeaders = response.headers;
                const metadata = {
                    clientRequestId,
                    responseHeaders,
                    responseCode: response.status,
                    rateLimit: getRateLimitFromResponseHeader(responseHeaders),
                };
                if (response.status < 200 || response.status >= 300) {
                    let error;
                    try {
                        error = (await response.json());
                    }
                    catch (_) {
                        throw new StreamError(`Stream error: ${response.status} - ${response.statusText}`, metadata, response.status);
                    }
                    throw new StreamError(`Stream error code ${error.code}: ${error.message}`, metadata, error.code, undefined);
                }
                const responseBody = (await response.json());
                return { body: responseBody, metadata };
            }
            catch (error) {
                if (error instanceof StreamError) {
                    throw error;
                }
                const metadata = {
                    clientRequestId,
                    responseCode: error.status,
                };
                if (error.name === 'AbortError' || error.name === 'TimeoutError') {
                    throw new StreamError(`The request was aborted due to to the ${this.apiConfig.timeout}ms timeout, you can set the timeout in the StreamClient constructor`, metadata, undefined, error);
                }
                else {
                    throw new StreamError(`The request failed due to an unexpected error`, metadata, error);
                }
            }
        };
        this.queryParamsStringify = (params) => {
            const newParams = [];
            for (const k in params) {
                const param = params[k];
                if (Array.isArray(param)) {
                    newParams.push(`${k}=${encodeURIComponent(param.join(','))}`);
                }
                else if (param instanceof Date) {
                    newParams.push(param.toISOString());
                }
                else if (typeof param === 'object') {
                    newParams.push(`${k}=${encodeURIComponent(JSON.stringify(param))}`);
                }
                else {
                    if (typeof param === 'string' ||
                        typeof param === 'number' ||
                        typeof param === 'boolean') {
                        newParams.push(`${k}=${encodeURIComponent(param)}`);
                    }
                }
            }
            return newParams.join('&');
        };
        this.dispatcher = this.apiConfig.agent;
    }
}

class FeedsApi {
    constructor(apiClient) {
        this.apiClient = apiClient;
    }
    async addActivity(request) {
        const body = {
            type: request?.type,
            feeds: request?.feeds,
            expires_at: request?.expires_at,
            id: request?.id,
            parent_id: request?.parent_id,
            poll_id: request?.poll_id,
            restrict_replies: request?.restrict_replies,
            skip_enrich_url: request?.skip_enrich_url,
            text: request?.text,
            user_id: request?.user_id,
            visibility: request?.visibility,
            visibility_tag: request?.visibility_tag,
            attachments: request?.attachments,
            collection_refs: request?.collection_refs,
            filter_tags: request?.filter_tags,
            interest_tags: request?.interest_tags,
            mentioned_user_ids: request?.mentioned_user_ids,
            custom: request?.custom,
            location: request?.location,
            search_data: request?.search_data,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/activities', undefined, undefined, body, 'application/json');
        decoders.AddActivityResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async upsertActivities(request) {
        const body = {
            activities: request?.activities,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/activities/batch', undefined, undefined, body, 'application/json');
        decoders.UpsertActivitiesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteActivities(request) {
        const body = {
            ids: request?.ids,
            hard_delete: request?.hard_delete,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/activities/delete', undefined, undefined, body, 'application/json');
        decoders.DeleteActivitiesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryActivities(request) {
        const body = {
            include_private_activities: request?.include_private_activities,
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            user_id: request?.user_id,
            sort: request?.sort,
            filter: request?.filter,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/activities/query', undefined, undefined, body, 'application/json');
        decoders.QueryActivitiesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteBookmark(request) {
        const queryParams = {
            folder_id: request?.folder_id,
            user_id: request?.user_id,
        };
        const pathParams = {
            activity_id: request?.activity_id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/activities/{activity_id}/bookmarks', pathParams, queryParams);
        decoders.DeleteBookmarkResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateBookmark(request) {
        const pathParams = {
            activity_id: request?.activity_id,
        };
        const body = {
            folder_id: request?.folder_id,
            new_folder_id: request?.new_folder_id,
            user_id: request?.user_id,
            custom: request?.custom,
            new_folder: request?.new_folder,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/feeds/activities/{activity_id}/bookmarks', pathParams, undefined, body, 'application/json');
        decoders.UpdateBookmarkResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async addBookmark(request) {
        const pathParams = {
            activity_id: request?.activity_id,
        };
        const body = {
            folder_id: request?.folder_id,
            user_id: request?.user_id,
            custom: request?.custom,
            new_folder: request?.new_folder,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/activities/{activity_id}/bookmarks', pathParams, undefined, body, 'application/json');
        decoders.AddBookmarkResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async activityFeedback(request) {
        const pathParams = {
            activity_id: request?.activity_id,
        };
        const body = {
            hide: request?.hide,
            show_less: request?.show_less,
            show_more: request?.show_more,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/activities/{activity_id}/feedback', pathParams, undefined, body, 'application/json');
        decoders.ActivityFeedbackResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async castPollVote(request) {
        const pathParams = {
            activity_id: request?.activity_id,
            poll_id: request?.poll_id,
        };
        const body = {
            user_id: request?.user_id,
            user: request?.user,
            vote: request?.vote,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/activities/{activity_id}/polls/{poll_id}/vote', pathParams, undefined, body, 'application/json');
        decoders.PollVoteResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deletePollVote(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            activity_id: request?.activity_id,
            poll_id: request?.poll_id,
            vote_id: request?.vote_id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/activities/{activity_id}/polls/{poll_id}/vote/{vote_id}', pathParams, queryParams);
        decoders.PollVoteResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async addActivityReaction(request) {
        const pathParams = {
            activity_id: request?.activity_id,
        };
        const body = {
            type: request?.type,
            create_notification_activity: request?.create_notification_activity,
            enforce_unique: request?.enforce_unique,
            skip_push: request?.skip_push,
            user_id: request?.user_id,
            custom: request?.custom,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/activities/{activity_id}/reactions', pathParams, undefined, body, 'application/json');
        decoders.AddReactionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryActivityReactions(request) {
        const pathParams = {
            activity_id: request?.activity_id,
        };
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/activities/{activity_id}/reactions/query', pathParams, undefined, body, 'application/json');
        decoders.QueryActivityReactionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteActivityReaction(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            activity_id: request?.activity_id,
            type: request?.type,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/activities/{activity_id}/reactions/{type}', pathParams, queryParams);
        decoders.DeleteActivityReactionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteActivity(request) {
        const queryParams = {
            hard_delete: request?.hard_delete,
        };
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/activities/{id}', pathParams, queryParams);
        decoders.DeleteActivityResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getActivity(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/activities/{id}', pathParams, undefined);
        decoders.GetActivityResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateActivityPartial(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            user_id: request?.user_id,
            unset: request?.unset,
            set: request?.set,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/feeds/activities/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateActivityPartialResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateActivity(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            expires_at: request?.expires_at,
            poll_id: request?.poll_id,
            restrict_replies: request?.restrict_replies,
            skip_enrich_url: request?.skip_enrich_url,
            text: request?.text,
            user_id: request?.user_id,
            visibility: request?.visibility,
            attachments: request?.attachments,
            collection_refs: request?.collection_refs,
            feeds: request?.feeds,
            filter_tags: request?.filter_tags,
            interest_tags: request?.interest_tags,
            custom: request?.custom,
            location: request?.location,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/feeds/activities/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateActivityResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryBookmarkFolders(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/bookmark_folders/query', undefined, undefined, body, 'application/json');
        decoders.QueryBookmarkFoldersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteBookmarkFolder(request) {
        const pathParams = {
            folder_id: request?.folder_id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/bookmark_folders/{folder_id}', pathParams, undefined);
        decoders.DeleteBookmarkFolderResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateBookmarkFolder(request) {
        const pathParams = {
            folder_id: request?.folder_id,
        };
        const body = {
            name: request?.name,
            user_id: request?.user_id,
            custom: request?.custom,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/feeds/bookmark_folders/{folder_id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateBookmarkFolderResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryBookmarks(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/bookmarks/query', undefined, undefined, body, 'application/json');
        decoders.QueryBookmarksResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteCollections(request) {
        const queryParams = {
            collection_refs: request?.collection_refs,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/collections', undefined, queryParams);
        decoders.DeleteCollectionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async readCollections(request) {
        const queryParams = {
            collection_refs: request?.collection_refs,
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/collections', undefined, queryParams);
        decoders.ReadCollectionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateCollections(request) {
        const body = {
            collections: request?.collections,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/feeds/collections', undefined, undefined, body, 'application/json');
        decoders.UpdateCollectionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createCollections(request) {
        const body = {
            collections: request?.collections,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/collections', undefined, undefined, body, 'application/json');
        decoders.CreateCollectionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async upsertCollections(request) {
        const body = {
            collections: request?.collections,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/feeds/collections', undefined, undefined, body, 'application/json');
        decoders.UpsertCollectionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getComments(request) {
        const queryParams = {
            object_id: request?.object_id,
            object_type: request?.object_type,
            depth: request?.depth,
            sort: request?.sort,
            replies_limit: request?.replies_limit,
            limit: request?.limit,
            prev: request?.prev,
            next: request?.next,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/comments', undefined, queryParams);
        decoders.GetCommentsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async addComment(request) {
        const body = {
            object_id: request?.object_id,
            object_type: request?.object_type,
            comment: request?.comment,
            create_notification_activity: request?.create_notification_activity,
            id: request?.id,
            parent_id: request?.parent_id,
            skip_enrich_url: request?.skip_enrich_url,
            skip_push: request?.skip_push,
            user_id: request?.user_id,
            attachments: request?.attachments,
            mentioned_user_ids: request?.mentioned_user_ids,
            custom: request?.custom,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/comments', undefined, undefined, body, 'application/json');
        decoders.AddCommentResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async addCommentsBatch(request) {
        const body = {
            comments: request?.comments,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/comments/batch', undefined, undefined, body, 'application/json');
        decoders.AddCommentsBatchResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryComments(request) {
        const body = {
            filter: request?.filter,
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/comments/query', undefined, undefined, body, 'application/json');
        decoders.QueryCommentsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteComment(request) {
        const queryParams = {
            hard_delete: request?.hard_delete,
        };
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/comments/{id}', pathParams, queryParams);
        decoders.DeleteCommentResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getComment(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/comments/{id}', pathParams, undefined);
        decoders.GetCommentResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateComment(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            comment: request?.comment,
            skip_enrich_url: request?.skip_enrich_url,
            skip_push: request?.skip_push,
            user_id: request?.user_id,
            custom: request?.custom,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/feeds/comments/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateCommentResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async addCommentReaction(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            type: request?.type,
            create_notification_activity: request?.create_notification_activity,
            enforce_unique: request?.enforce_unique,
            skip_push: request?.skip_push,
            user_id: request?.user_id,
            custom: request?.custom,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/comments/{id}/reactions', pathParams, undefined, body, 'application/json');
        decoders.AddCommentReactionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryCommentReactions(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/comments/{id}/reactions/query', pathParams, undefined, body, 'application/json');
        decoders.QueryCommentReactionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteCommentReaction(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            id: request?.id,
            type: request?.type,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/comments/{id}/reactions/{type}', pathParams, queryParams);
        decoders.DeleteCommentReactionResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getCommentReplies(request) {
        const queryParams = {
            depth: request?.depth,
            sort: request?.sort,
            replies_limit: request?.replies_limit,
            limit: request?.limit,
            prev: request?.prev,
            next: request?.next,
        };
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/comments/{id}/replies', pathParams, queryParams);
        decoders.GetCommentRepliesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listFeedGroups(request) {
        const queryParams = {
            include_soft_deleted: request?.include_soft_deleted,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/feed_groups', undefined, queryParams);
        decoders.ListFeedGroupsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createFeedGroup(request) {
        const body = {
            id: request?.id,
            default_visibility: request?.default_visibility,
            activity_processors: request?.activity_processors,
            activity_selectors: request?.activity_selectors,
            aggregation: request?.aggregation,
            custom: request?.custom,
            notification: request?.notification,
            push_notification: request?.push_notification,
            ranking: request?.ranking,
            stories: request?.stories,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feed_groups', undefined, undefined, body, 'application/json');
        decoders.CreateFeedGroupResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteFeed(request) {
        const queryParams = {
            hard_delete: request?.hard_delete,
        };
        const pathParams = {
            feed_group_id: request?.feed_group_id,
            feed_id: request?.feed_id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}', pathParams, queryParams);
        decoders.DeleteFeedResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getOrCreateFeed(request) {
        const pathParams = {
            feed_group_id: request?.feed_group_id,
            feed_id: request?.feed_id,
        };
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            user_id: request?.user_id,
            view: request?.view,
            watch: request?.watch,
            data: request?.data,
            external_ranking: request?.external_ranking,
            filter: request?.filter,
            followers_pagination: request?.followers_pagination,
            following_pagination: request?.following_pagination,
            interest_weights: request?.interest_weights,
            member_pagination: request?.member_pagination,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}', pathParams, undefined, body, 'application/json');
        decoders.GetOrCreateFeedResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateFeed(request) {
        const pathParams = {
            feed_group_id: request?.feed_group_id,
            feed_id: request?.feed_id,
        };
        const body = {
            created_by_id: request?.created_by_id,
            custom: request?.custom,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateFeedResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async markActivity(request) {
        const pathParams = {
            feed_group_id: request?.feed_group_id,
            feed_id: request?.feed_id,
        };
        const body = {
            mark_all_read: request?.mark_all_read,
            mark_all_seen: request?.mark_all_seen,
            user_id: request?.user_id,
            mark_read: request?.mark_read,
            mark_seen: request?.mark_seen,
            mark_watched: request?.mark_watched,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/activities/mark/batch', pathParams, undefined, body, 'application/json');
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async unpinActivity(request) {
        const queryParams = {
            user_id: request?.user_id,
        };
        const pathParams = {
            feed_group_id: request?.feed_group_id,
            feed_id: request?.feed_id,
            activity_id: request?.activity_id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/activities/{activity_id}/pin', pathParams, queryParams);
        decoders.UnpinActivityResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async pinActivity(request) {
        const pathParams = {
            feed_group_id: request?.feed_group_id,
            feed_id: request?.feed_id,
            activity_id: request?.activity_id,
        };
        const body = {
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/activities/{activity_id}/pin', pathParams, undefined, body, 'application/json');
        decoders.PinActivityResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateFeedMembers(request) {
        const pathParams = {
            feed_group_id: request?.feed_group_id,
            feed_id: request?.feed_id,
        };
        const body = {
            operation: request?.operation,
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            members: request?.members,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/members', pathParams, undefined, body, 'application/json');
        decoders.UpdateFeedMembersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async acceptFeedMemberInvite(request) {
        const pathParams = {
            feed_id: request?.feed_id,
            feed_group_id: request?.feed_group_id,
        };
        const body = {
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/members/accept', pathParams, undefined, body, 'application/json');
        decoders.AcceptFeedMemberInviteResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryFeedMembers(request) {
        const pathParams = {
            feed_group_id: request?.feed_group_id,
            feed_id: request?.feed_id,
        };
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/members/query', pathParams, undefined, body, 'application/json');
        decoders.QueryFeedMembersResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async rejectFeedMemberInvite(request) {
        const pathParams = {
            feed_group_id: request?.feed_group_id,
            feed_id: request?.feed_id,
        };
        const body = {
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/members/reject', pathParams, undefined, body, 'application/json');
        decoders.RejectFeedMemberInviteResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getFollowSuggestions(request) {
        const queryParams = {
            limit: request?.limit,
            user_id: request?.user_id,
        };
        const pathParams = {
            feed_group_id: request?.feed_group_id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/feed_groups/{feed_group_id}/follow_suggestions', pathParams, queryParams);
        decoders.GetFollowSuggestionsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteFeedGroup(request) {
        const queryParams = {
            hard_delete: request?.hard_delete,
        };
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/feed_groups/{id}', pathParams, queryParams);
        decoders.DeleteFeedGroupResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getFeedGroup(request) {
        const queryParams = {
            include_soft_deleted: request?.include_soft_deleted,
        };
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/feed_groups/{id}', pathParams, queryParams);
        decoders.GetFeedGroupResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getOrCreateFeedGroup(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            default_visibility: request?.default_visibility,
            activity_processors: request?.activity_processors,
            activity_selectors: request?.activity_selectors,
            aggregation: request?.aggregation,
            custom: request?.custom,
            notification: request?.notification,
            push_notification: request?.push_notification,
            ranking: request?.ranking,
            stories: request?.stories,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feed_groups/{id}', pathParams, undefined, body, 'application/json');
        decoders.GetOrCreateFeedGroupResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateFeedGroup(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            default_visibility: request?.default_visibility,
            activity_processors: request?.activity_processors,
            activity_selectors: request?.activity_selectors,
            aggregation: request?.aggregation,
            custom: request?.custom,
            notification: request?.notification,
            push_notification: request?.push_notification,
            ranking: request?.ranking,
            stories: request?.stories,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/feeds/feed_groups/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateFeedGroupResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listFeedViews() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/feed_views', undefined, undefined);
        decoders.ListFeedViewsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createFeedView(request) {
        const body = {
            id: request?.id,
            activity_selectors: request?.activity_selectors,
            aggregation: request?.aggregation,
            ranking: request?.ranking,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feed_views', undefined, undefined, body, 'application/json');
        decoders.CreateFeedViewResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteFeedView(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/feed_views/{id}', pathParams, undefined);
        decoders.DeleteFeedViewResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getFeedView(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/feed_views/{id}', pathParams, undefined);
        decoders.GetFeedViewResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getOrCreateFeedView(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            activity_selectors: request?.activity_selectors,
            aggregation: request?.aggregation,
            ranking: request?.ranking,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feed_views/{id}', pathParams, undefined, body, 'application/json');
        decoders.GetOrCreateFeedViewResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateFeedView(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            activity_selectors: request?.activity_selectors,
            aggregation: request?.aggregation,
            ranking: request?.ranking,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/feeds/feed_views/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateFeedViewResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async listFeedVisibilities() {
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/feed_visibilities', undefined, undefined);
        decoders.ListFeedVisibilitiesResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getFeedVisibility(request) {
        const pathParams = {
            name: request?.name,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/feed_visibilities/{name}', pathParams, undefined);
        decoders.GetFeedVisibilityResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateFeedVisibility(request) {
        const pathParams = {
            name: request?.name,
        };
        const body = {
            grants: request?.grants,
        };
        const response = await this.apiClient.sendRequest('PUT', '/api/v2/feeds/feed_visibilities/{name}', pathParams, undefined, body, 'application/json');
        decoders.UpdateFeedVisibilityResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createFeedsBatch(request) {
        const body = {
            feeds: request?.feeds,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feeds/batch', undefined, undefined, body, 'application/json');
        decoders.CreateFeedsBatchResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async ownCapabilitiesBatch(request) {
        const body = {
            feeds: request?.feeds,
            user_id: request?.user_id,
            user: request?.user,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feeds/own_capabilities/batch', undefined, undefined, body, 'application/json');
        decoders.OwnCapabilitiesBatchResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async _queryFeeds(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            watch: request?.watch,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/feeds/query', undefined, undefined, body, 'application/json');
        decoders.QueryFeedsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async getFeedsRateLimits(request) {
        const queryParams = {
            endpoints: request?.endpoints,
            android: request?.android,
            ios: request?.ios,
            web: request?.web,
            server_side: request?.server_side,
        };
        const response = await this.apiClient.sendRequest('GET', '/api/v2/feeds/feeds/rate_limits', undefined, queryParams);
        decoders.GetFeedsRateLimitsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateFollow(request) {
        const body = {
            source: request?.source,
            target: request?.target,
            create_notification_activity: request?.create_notification_activity,
            follower_role: request?.follower_role,
            push_preference: request?.push_preference,
            skip_push: request?.skip_push,
            custom: request?.custom,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/feeds/follows', undefined, undefined, body, 'application/json');
        decoders.UpdateFollowResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async follow(request) {
        const body = {
            source: request?.source,
            target: request?.target,
            create_notification_activity: request?.create_notification_activity,
            push_preference: request?.push_preference,
            skip_push: request?.skip_push,
            custom: request?.custom,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/follows', undefined, undefined, body, 'application/json');
        decoders.SingleFollowResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async acceptFollow(request) {
        const body = {
            source: request?.source,
            target: request?.target,
            follower_role: request?.follower_role,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/follows/accept', undefined, undefined, body, 'application/json');
        decoders.AcceptFollowResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async followBatch(request) {
        const body = {
            follows: request?.follows,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/follows/batch', undefined, undefined, body, 'application/json');
        decoders.FollowBatchResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryFollows(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/follows/query', undefined, undefined, body, 'application/json');
        decoders.QueryFollowsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async rejectFollow(request) {
        const body = {
            source: request?.source,
            target: request?.target,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/follows/reject', undefined, undefined, body, 'application/json');
        decoders.RejectFollowResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async unfollow(request) {
        const pathParams = {
            source: request?.source,
            target: request?.target,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/follows/{source}/{target}', pathParams, undefined);
        decoders.UnfollowResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async createMembershipLevel(request) {
        const body = {
            id: request?.id,
            name: request?.name,
            description: request?.description,
            priority: request?.priority,
            tags: request?.tags,
            custom: request?.custom,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/membership_levels', undefined, undefined, body, 'application/json');
        decoders.CreateMembershipLevelResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryMembershipLevels(request) {
        const body = {
            limit: request?.limit,
            next: request?.next,
            prev: request?.prev,
            sort: request?.sort,
            filter: request?.filter,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/membership_levels/query', undefined, undefined, body, 'application/json');
        decoders.QueryMembershipLevelsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteMembershipLevel(request) {
        const pathParams = {
            id: request?.id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/membership_levels/{id}', pathParams, undefined);
        decoders.Response?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async updateMembershipLevel(request) {
        const pathParams = {
            id: request?.id,
        };
        const body = {
            description: request?.description,
            name: request?.name,
            priority: request?.priority,
            tags: request?.tags,
            custom: request?.custom,
        };
        const response = await this.apiClient.sendRequest('PATCH', '/api/v2/feeds/membership_levels/{id}', pathParams, undefined, body, 'application/json');
        decoders.UpdateMembershipLevelResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async queryFeedsUsageStats(request) {
        const body = {
            from: request?.from,
            to: request?.to,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/stats/usage', undefined, undefined, body, 'application/json');
        decoders.QueryFeedsUsageStatsResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async unfollowBatch(request) {
        const body = {
            follows: request?.follows,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/unfollow/batch', undefined, undefined, body, 'application/json');
        decoders.UnfollowBatchResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async deleteFeedUserData(request) {
        const pathParams = {
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('DELETE', '/api/v2/feeds/users/{user_id}/delete', pathParams, undefined);
        decoders.DeleteFeedUserDataResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
    async exportFeedUserData(request) {
        const pathParams = {
            user_id: request?.user_id,
        };
        const response = await this.apiClient.sendRequest('POST', '/api/v2/feeds/users/{user_id}/export', pathParams, undefined);
        decoders.ExportFeedUserDataResponse?.(response.body);
        return { ...response.body, metadata: response.metadata };
    }
}

class FeedApi {
    constructor(feedsApi, group, id) {
        this.feedsApi = feedsApi;
        this.group = group;
        this.id = id;
    }
    delete(request) {
        return this.feedsApi.deleteFeed({
            feed_id: this.id,
            feed_group_id: this.group,
            ...request,
        });
    }
    getOrCreate(request) {
        return this.feedsApi.getOrCreateFeed({
            feed_id: this.id,
            feed_group_id: this.group,
            ...request,
        });
    }
    update(request) {
        return this.feedsApi.updateFeed({
            feed_id: this.id,
            feed_group_id: this.group,
            ...request,
        });
    }
    markActivity(request) {
        return this.feedsApi.markActivity({
            feed_id: this.id,
            feed_group_id: this.group,
            ...request,
        });
    }
    unpinActivity(request) {
        return this.feedsApi.unpinActivity({
            feed_id: this.id,
            feed_group_id: this.group,
            ...request,
        });
    }
    pinActivity(request) {
        return this.feedsApi.pinActivity({
            feed_id: this.id,
            feed_group_id: this.group,
            ...request,
        });
    }
    updateFeedMembers(request) {
        return this.feedsApi.updateFeedMembers({
            feed_id: this.id,
            feed_group_id: this.group,
            ...request,
        });
    }
    acceptFeedMemberInvite(request) {
        return this.feedsApi.acceptFeedMemberInvite({
            feed_id: this.id,
            feed_group_id: this.group,
            ...request,
        });
    }
    queryFeedMembers(request) {
        return this.feedsApi.queryFeedMembers({
            feed_id: this.id,
            feed_group_id: this.group,
            ...request,
        });
    }
    rejectFeedMemberInvite(request) {
        return this.feedsApi.rejectFeedMemberInvite({
            feed_id: this.id,
            feed_group_id: this.group,
            ...request,
        });
    }
}

class StreamFeed extends FeedApi {
    get feed() {
        return `${this.group}:${this.id}`;
    }
}

class StreamFeedsClient extends FeedsApi {
    constructor() {
        super(...arguments);
        this.feed = (group, id) => {
            return new StreamFeed(this, group, id);
        };
        this.queryFeeds = (request) => {
            return super._queryFeeds(request);
        };
        /**
         * @deprecated Use addActivityReaction instead
         */
        this.addReaction = (request) => {
            return super.addActivityReaction(request);
        };
    }
}

class StreamClient extends CommonApi {
    /**
     *
     * @param apiKey
     * @param secret
     * @param config config object
     */
    constructor(apiKey, secret, config) {
        const token = JWTServerToken(secret);
        const timeout = config?.timeout ?? StreamClient.DEFAULT_TIMEOUT;
        const chatBaseUrl = config?.basePath ?? 'https://chat.stream-io-api.com';
        const videoBaseUrl = config?.basePath ?? 'https://video.stream-io-api.com';
        const feedsBaseUrl = config?.basePath ?? 'https://feeds.stream-io-api.com';
        const chatApiClient = new ApiClient({
            apiKey,
            token,
            baseUrl: chatBaseUrl,
            timeout,
            agent: config?.agent,
        });
        const videoApiClient = new ApiClient({
            apiKey,
            token,
            baseUrl: videoBaseUrl,
            timeout,
            agent: config?.agent,
        });
        const feedsApiClient = new ApiClient({
            apiKey,
            token,
            baseUrl: feedsBaseUrl,
            timeout,
            agent: config?.agent,
        });
        super(chatApiClient);
        this.apiKey = apiKey;
        this.secret = secret;
        this.config = config;
        this.options = {};
        this.upsertUsers = (users) => {
            const payload = {};
            users.forEach((u) => {
                payload[u.id] = u;
            });
            return this.updateUsers({ users: payload });
        };
        this.queryBannedUsers = (request) => {
            return this.chat.queryBannedUsers(request);
        };
        // @ts-expect-error API spec says file should be a string
        this.uploadFile = (request) => {
            return super.uploadFile({
                // @ts-expect-error API spec says file should be a string
                file: request.file,
                // @ts-expect-error form data will only work if this is a string
                user: JSON.stringify(request.user),
            });
        };
        // @ts-expect-error API spec says file should be a string
        this.uploadImage = (request) => {
            return super.uploadImage({
                // @ts-expect-error API spec says file should be a string
                file: request.file,
                // @ts-expect-error form data will only work if this is a string
                user: JSON.stringify(request.user),
                // @ts-expect-error form data will only work if this is a string
                upload_sizes: JSON.stringify(request.upload_sizes),
            });
        };
        /**
         *
         * @param payload
         * - user_id - the id of the user the token is for
         * - validity_in_seconds - how many seconds is the token valid for (starting from issued at), by default it's 1 hour, dicarded if exp is provided
         * - exp - when the token expires, unix timestamp in seconds
         * - iat - issued at date of the token, unix timestamp in seconds, by default it's now
         */
        this.generateUserToken = (payload) => {
            const defaultIat = Math.floor((Date.now() - 1000) / 1000);
            payload.iat = payload.iat ?? defaultIat;
            const validityInSeconds = payload.validity_in_seconds ?? 60 * 60;
            payload.exp = payload.exp ?? payload.iat + validityInSeconds;
            return JWTUserToken(this.secret, payload);
        };
        /**
         *
         * @param payload
         * - user_id - the id of the user the token is for
         * - iat - issued at date of the token, unix timestamp in seconds, by default it's now
         */
        this.generatePermanentUserToken = (payload) => {
            const defaultIat = Math.floor((Date.now() - 1000) / 1000);
            payload.iat = payload.iat ?? defaultIat;
            return JWTUserToken(this.secret, payload);
        };
        /**
         *
         * @param payload
         * - user_id - the id of the user the token is for
         * - validity_in_seconds - how many seconds is the token valid for (starting from issued at), by default it's 1 hour, dicarded if exp is provided
         * - exp - when the token expires, unix timestamp in seconds
         * - iat - issued at date of the token, unix timestamp in seconds, by default it's now
         */
        this.generateCallToken = (payload) => {
            return this.generateUserToken(payload);
        };
        /**
         *
         * @param userID
         * @param exp
         * @param iat deprecated, the default date will be set internally
         * @returns
         *
         * @deprecated use generateUserToken instead
         */
        this.createToken = (userID, exp = Math.round(Date.now() / 1000) + 60 * 60, iat = Math.floor((Date.now() - 1000) / 1000)) => {
            const payload = {
                user_id: userID,
                exp,
                iat,
            };
            return JWTUserToken(this.secret, payload);
        };
        /**
         *
         * @param userID
         * @param call_cids
         * @param exp
         * @param iat this is deprecated, the current date will be set internally
         * @returns
         *
         * @deprecated use generateCallToken instead
         */
        this.createCallToken = (userIdOrObject, call_cids, exp = Math.round(Date.now() / 1000) + 60 * 60, iat = Math.floor((Date.now() - 1000) / 1000)) => {
            const payload = {
                exp,
                iat,
                call_cids,
                user_id: typeof userIdOrObject === 'string'
                    ? userIdOrObject
                    : userIdOrObject.user_id,
            };
            if (typeof userIdOrObject === 'object' && userIdOrObject.role) {
                payload.role = userIdOrObject.role;
            }
            return JWTUserToken(this.secret, payload);
        };
        this.verifyWebhook = (requestBody, xSignature) => {
            const key = Buffer.from(this.secret, 'utf8');
            const hash = crypto
                .createHmac('sha256', key)
                .update(requestBody)
                .digest('hex');
            try {
                return crypto.timingSafeEqual(Buffer.from(hash), Buffer.from(xSignature));
            }
            catch (err) {
                return false;
            }
        };
        this.video = new StreamVideoClient({
            streamClient: this,
            apiClient: videoApiClient,
        });
        this.chat = new StreamChatClient(this.apiClient);
        this.moderation = new StreamModerationClient(chatApiClient);
        this.feeds = new StreamFeedsClient(feedsApiClient);
    }
}
StreamClient.DEFAULT_TIMEOUT = 3000;

const ChannelOwnCapability = {
    BAN_CHANNEL_MEMBERS: 'ban-channel-members',
    CAST_POLL_VOTE: 'cast-poll-vote',
    CONNECT_EVENTS: 'connect-events',
    CREATE_ATTACHMENT: 'create-attachment',
    DELETE_ANY_MESSAGE: 'delete-any-message',
    DELETE_CHANNEL: 'delete-channel',
    DELETE_OWN_MESSAGE: 'delete-own-message',
    DELIVERY_EVENTS: 'delivery-events',
    FLAG_MESSAGE: 'flag-message',
    FREEZE_CHANNEL: 'freeze-channel',
    JOIN_CHANNEL: 'join-channel',
    LEAVE_CHANNEL: 'leave-channel',
    MUTE_CHANNEL: 'mute-channel',
    PIN_MESSAGE: 'pin-message',
    QUERY_POLL_VOTES: 'query-poll-votes',
    QUOTE_MESSAGE: 'quote-message',
    READ_EVENTS: 'read-events',
    SEARCH_MESSAGES: 'search-messages',
    SEND_CUSTOM_EVENTS: 'send-custom-events',
    SEND_LINKS: 'send-links',
    SEND_MESSAGE: 'send-message',
    SEND_POLL: 'send-poll',
    SEND_REACTION: 'send-reaction',
    SEND_REPLY: 'send-reply',
    SEND_RESTRICTED_VISIBILITY_MESSAGE: 'send-restricted-visibility-message',
    SEND_TYPING_EVENTS: 'send-typing-events',
    SET_CHANNEL_COOLDOWN: 'set-channel-cooldown',
    SHARE_LOCATION: 'share-location',
    SKIP_SLOW_MODE: 'skip-slow-mode',
    SLOW_MODE: 'slow-mode',
    TYPING_EVENTS: 'typing-events',
    UPDATE_ANY_MESSAGE: 'update-any-message',
    UPDATE_CHANNEL: 'update-channel',
    UPDATE_CHANNEL_MEMBERS: 'update-channel-members',
    UPDATE_OWN_MESSAGE: 'update-own-message',
    UPDATE_THREAD: 'update-thread',
    UPLOAD_FILE: 'upload-file',
};
const FeedOwnCapability = {
    ADD_ACTIVITY: 'add-activity',
    ADD_ACTIVITY_BOOKMARK: 'add-activity-bookmark',
    ADD_ACTIVITY_REACTION: 'add-activity-reaction',
    ADD_COMMENT: 'add-comment',
    ADD_COMMENT_REACTION: 'add-comment-reaction',
    CREATE_FEED: 'create-feed',
    DELETE_ANY_ACTIVITY: 'delete-any-activity',
    DELETE_ANY_COMMENT: 'delete-any-comment',
    DELETE_FEED: 'delete-feed',
    DELETE_OWN_ACTIVITY: 'delete-own-activity',
    DELETE_OWN_ACTIVITY_BOOKMARK: 'delete-own-activity-bookmark',
    DELETE_OWN_ACTIVITY_REACTION: 'delete-own-activity-reaction',
    DELETE_OWN_COMMENT: 'delete-own-comment',
    DELETE_OWN_COMMENT_REACTION: 'delete-own-comment-reaction',
    FOLLOW: 'follow',
    PIN_ACTIVITY: 'pin-activity',
    QUERY_FEED_MEMBERS: 'query-feed-members',
    QUERY_FOLLOWS: 'query-follows',
    READ_ACTIVITIES: 'read-activities',
    READ_FEED: 'read-feed',
    UNFOLLOW: 'unfollow',
    UPDATE_ANY_ACTIVITY: 'update-any-activity',
    UPDATE_ANY_COMMENT: 'update-any-comment',
    UPDATE_FEED: 'update-feed',
    UPDATE_FEED_FOLLOWERS: 'update-feed-followers',
    UPDATE_FEED_MEMBERS: 'update-feed-members',
    UPDATE_OWN_ACTIVITY: 'update-own-activity',
    UPDATE_OWN_ACTIVITY_BOOKMARK: 'update-own-activity-bookmark',
    UPDATE_OWN_COMMENT: 'update-own-comment',
};
const OwnCapability = {
    BLOCK_USERS: 'block-users',
    CHANGE_MAX_DURATION: 'change-max-duration',
    CREATE_CALL: 'create-call',
    CREATE_REACTION: 'create-reaction',
    ENABLE_NOISE_CANCELLATION: 'enable-noise-cancellation',
    END_CALL: 'end-call',
    JOIN_BACKSTAGE: 'join-backstage',
    JOIN_CALL: 'join-call',
    JOIN_ENDED_CALL: 'join-ended-call',
    KICK_USER: 'kick-user',
    MUTE_USERS: 'mute-users',
    PIN_FOR_EVERYONE: 'pin-for-everyone',
    READ_CALL: 'read-call',
    REMOVE_CALL_MEMBER: 'remove-call-member',
    SCREENSHARE: 'screenshare',
    SEND_AUDIO: 'send-audio',
    SEND_CLOSED_CAPTIONS_CALL: 'send-closed-captions-call',
    SEND_VIDEO: 'send-video',
    START_BROADCAST_CALL: 'start-broadcast-call',
    START_CLOSED_CAPTIONS_CALL: 'start-closed-captions-call',
    START_FRAME_RECORD_CALL: 'start-frame-record-call',
    START_RECORD_CALL: 'start-record-call',
    START_TRANSCRIPTION_CALL: 'start-transcription-call',
    STOP_BROADCAST_CALL: 'stop-broadcast-call',
    STOP_CLOSED_CAPTIONS_CALL: 'stop-closed-captions-call',
    STOP_FRAME_RECORD_CALL: 'stop-frame-record-call',
    STOP_RECORD_CALL: 'stop-record-call',
    STOP_TRANSCRIPTION_CALL: 'stop-transcription-call',
    UPDATE_CALL: 'update-call',
    UPDATE_CALL_MEMBER: 'update-call-member',
    UPDATE_CALL_PERMISSIONS: 'update-call-permissions',
    UPDATE_CALL_SETTINGS: 'update-call-settings',
};

exports.ChannelOwnCapability = ChannelOwnCapability;
exports.FeedOwnCapability = FeedOwnCapability;
exports.OwnCapability = OwnCapability;
exports.StreamCall = StreamCall;
exports.StreamChannel = StreamChannel;
exports.StreamChatClient = StreamChatClient;
exports.StreamClient = StreamClient;
exports.StreamFeed = StreamFeed;
exports.StreamFeedsClient = StreamFeedsClient;
exports.StreamVideoClient = StreamVideoClient;
//# sourceMappingURL=index.cjs.js.map
